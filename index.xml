<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>litsynp.log</title><link>https://blog.litsynp.com/</link><description>Recent content on litsynp.log</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 08 Apr 2022 16:59:02 +0900</lastBuildDate><atom:link href="https://blog.litsynp.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7</title><link>https://blog.litsynp.com/posts/2022-04-08/</link><pubDate>Fri, 08 Apr 2022 16:59:02 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022-04-08/</guid><description>Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.
Kotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.
Gradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.
하지만 index.html 파일이 생성되지 않았다.
예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.</description></item><item><title>[Java] Garbage Collector in JVM</title><link>https://blog.litsynp.com/posts/2022-02-12/</link><pubDate>Sat, 12 Feb 2022 11:28:52 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022-02-12/</guid><description>Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, &amp;hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.</description></item><item><title>[Spring Boot] External API Call</title><link>https://blog.litsynp.com/posts/2022-02-11/</link><pubDate>Fri, 11 Feb 2022 23:30:25 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022-02-11/</guid><description>RestTemplate is commonly used for external API call in Spring.
But from Spring 5, WebClient in WebFlux is preferred over RestTemplate.
First, add this dependency to build.gradle.
// build.gradle // ... implementation &amp;#39;org.springframework.boot:spring-boot-starter-webflux&amp;#39; // ... Then create a bean to inject into different classes.
package com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.</description></item><item><title>[TIR] About web.xml</title><link>https://blog.litsynp.com/posts/2022-01-21/</link><pubDate>Fri, 21 Jan 2022 23:50:40 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022-01-21/</guid><description>Today I Read Reference https://tlatmsrud.tistory.com/35
What I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.</description></item><item><title>[TIR] Redis vs Kafka vs RabbitMQ</title><link>https://blog.litsynp.com/posts/2022-01-07/</link><pubDate>Fri, 07 Jan 2022 23:38:42 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022-01-07/</guid><description>Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec
What I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages</description></item><item><title>[DRF] Serializer에 writable non-model field 추가하기</title><link>https://blog.litsynp.com/posts/2022-01-05/</link><pubDate>Wed, 05 Jan 2022 23:31:28 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022-01-05/</guid><description>문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.
해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.
class UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (&amp;#39;id&amp;#39;, &amp;#39;username&amp;#39;, &amp;#39;password&amp;#39;, &amp;#39;non_model_field&amp;#39;) def validate(self, attrs): # ... attrs.</description></item><item><title>Spring Boot에서 Swagger UI 접속이 안되는 경우</title><link>https://blog.litsynp.com/posts/2021-09-05_2/</link><pubDate>Sun, 05 Sep 2021 01:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021-09-05_2/</guid><description>문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.
원인 아마도 dependencies를 잘못 설정했을 확률이 높다.
해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,
implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger-ui&amp;#39;, version: &amp;#39;3.0.0&amp;#39; implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger2&amp;#39;, version: &amp;#39;3.0.0&amp;#39; 다음과 같이 바꾼다.
implementation &amp;#34;io.springfox:springfox-boot-starter:3.0.0&amp;#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍</description></item><item><title>Getting Ambiguous @ExceptionHandler method mapped for XXXException</title><link>https://blog.litsynp.com/posts/2021-09-05/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021-09-05/</guid><description>문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,
Getting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.
원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.
해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)
REF Stack Overflow</description></item><item><title>[Python] super() 이용해서 기존 메소드 이용하기</title><link>https://blog.litsynp.com/posts/2021-02-10/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021-02-10/</guid><description>Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.
그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.
예시는 다음과 같다.
# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(&amp;#39;pk&amp;#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).</description></item></channel></rss>