<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>litsynp.log</title><link>https://blog.litsynp.com/</link><description>Recent content on litsynp.log</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 12 Jun 2022 12:21:17 +0900</lastBuildDate><atom:link href="https://blog.litsynp.com/index.xml" rel="self" type="application/rss+xml"/><item><title>[프로그래머스][level 3][#92344] 파괴되지 않은 건물</title><link>https://blog.litsynp.com/posts/2022/06/12/programmers-q92344-%ED%8C%8C%EA%B4%B4%EB%90%98%EC%A7%80%EC%95%8A%EC%9D%80%EA%B1%B4%EB%AC%BC/</link><pubDate>Sun, 12 Jun 2022 12:21:17 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/12/programmers-q92344-%ED%8C%8C%EA%B4%B4%EB%90%98%EC%A7%80%EC%95%8A%EC%9D%80%EA%B1%B4%EB%AC%BC/</guid><description/></item><item><title>[프로그래머스][level 3][#92343] 양과 늑대</title><link>https://blog.litsynp.com/posts/2022/06/12/programmers-q92343-%EC%96%91%EA%B3%BC%EB%8A%91%EB%8C%80/</link><pubDate>Sun, 12 Jun 2022 12:21:03 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/12/programmers-q92343-%EC%96%91%EA%B3%BC%EB%8A%91%EB%8C%80/</guid><description/></item><item><title>[프로그래머스][level 3][#92345] 사라지는 발판</title><link>https://blog.litsynp.com/posts/2022/06/07/programmers-q92345-%EC%82%AC%EB%9D%BC%EC%A7%80%EB%8A%94%EB%B0%9C%ED%8C%90/</link><pubDate>Tue, 07 Jun 2022 15:02:49 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/07/programmers-q92345-%EC%82%AC%EB%9D%BC%EC%A7%80%EB%8A%94%EB%B0%9C%ED%8C%90/</guid><description/></item><item><title>[프로그래머스][Level 4][#17685] 자동완성 해설</title><link>https://blog.litsynp.com/posts/2022/06/05/programmers-q17685-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1/</link><pubDate>Sun, 05 Jun 2022 02:51:30 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/05/programmers-q17685-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1/</guid><description/></item><item><title>[프로그래머스][Level 2][#17680] 캐시 해설</title><link>https://blog.litsynp.com/posts/2022/06/05/programmers-q17680-%EC%BA%90%EC%8B%9C/</link><pubDate>Sun, 05 Jun 2022 02:50:50 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/05/programmers-q17680-%EC%BA%90%EC%8B%9C/</guid><description/></item><item><title>[프로그래머스][Level 2][#17686] 파일명 정렬 해설</title><link>https://blog.litsynp.com/posts/2022/06/05/programmers-q17686-%ED%8C%8C%EC%9D%BC%EB%AA%85%EC%A0%95%EB%A0%AC/</link><pubDate>Sun, 05 Jun 2022 02:50:40 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/05/programmers-q17686-%ED%8C%8C%EC%9D%BC%EB%AA%85%EC%A0%95%EB%A0%AC/</guid><description/></item><item><title>[프로그래머스][Level 2][#17679] 프렌즈4블록 해설</title><link>https://blog.litsynp.com/posts/2022/06/05/programmers-q17679-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/</link><pubDate>Sun, 05 Jun 2022 02:50:33 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/05/programmers-q17679-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/</guid><description/></item><item><title>Spring Batch와 주요 클래스 정리</title><link>https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/</link><pubDate>Sat, 04 Jun 2022 23:55:52 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/</guid><description>배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다.</description></item><item><title>클린 코더 (The Clean Coder) 독서 - 1</title><link>https://blog.litsynp.com/posts/2022/05/27/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94-the-clean-coder-%EB%8F%85%EC%84%9C-1/</link><pubDate>Fri, 27 May 2022 23:02:28 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/05/27/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94-the-clean-coder-%EB%8F%85%EC%84%9C-1/</guid><description>클린 코더 (The Clean Coder) 독서 - 1 음악 들으면서 About 저자: “밥 아저씨” 로버트 C. 마틴
&amp;lt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신&amp;gt;의 저자이기도 함
표지 사진은 M1 성운 (게 성운)이고, 푸른 색의 밝은 점은 펄서이다.
책에서 다루는 내용 프로 소프트웨어 개발자의 마음가짐, 즉 소프트웨어 프로페셔널리즘에 관한 책이다.
책임지는 일은 무서운 일이다. 기술자라면 시스템과 프로젝트에 대해 관리자는 알기 힘든 깊은 지식을 알아야 한다. 그 지식을 가지고 행동으로 옮겨야 할 책임이 있다.</description></item><item><title>Java - List&lt;Integer>에서 remove()를 이용한 원소 삭제 간 주의점</title><link>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</link><pubDate>Fri, 06 May 2022 23:36:45 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</guid><description>Java - List&amp;lt;Integer&amp;gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.
import java.util.*; // ... 중략 List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.
boolean remove(Object o); &amp;ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)</description></item><item><title>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우</title><link>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link><pubDate>Thu, 28 Apr 2022 15:49:15 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid><description>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.
그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.
static을 이용해 전역으로 설정하고 있었다면,
참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.
추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.</description></item><item><title>Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7</title><link>https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/</link><pubDate>Fri, 08 Apr 2022 16:59:02 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/</guid><description>Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.
Kotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.
Gradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.
하지만 index.html 파일이 생성되지 않았다.
예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.
Spring Boot | REST Docs 적용하기 ( + build failed 해결.</description></item><item><title>[Java] Garbage Collector in JVM</title><link>https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/</link><pubDate>Sat, 12 Feb 2022 11:28:52 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/</guid><description>Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, &amp;hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.</description></item><item><title>[Spring Boot] External API Call</title><link>https://blog.litsynp.com/posts/2022/02/11/spring-boot-external-api-call/</link><pubDate>Fri, 11 Feb 2022 23:30:25 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022/02/11/spring-boot-external-api-call/</guid><description>RestTemplate is commonly used for external API call in Spring.
But from Spring 5, WebClient in WebFlux is preferred over RestTemplate.
First, add this dependency to build.gradle.
// build.gradle // ... implementation &amp;#39;org.springframework.boot:spring-boot-starter-webflux&amp;#39; // ... Then create a bean to inject into different classes.
package com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.</description></item><item><title>[TIR] About web.xml</title><link>https://blog.litsynp.com/posts/2022/01/21/tir-about-web.xml/</link><pubDate>Fri, 21 Jan 2022 23:50:40 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022/01/21/tir-about-web.xml/</guid><description>Today I Read Reference https://tlatmsrud.tistory.com/35
What I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.</description></item><item><title>[TIR] Redis vs Kafka vs RabbitMQ</title><link>https://blog.litsynp.com/posts/2022/01/07/tir-redis-vs-kafka-vs-rabbitmq/</link><pubDate>Fri, 07 Jan 2022 23:38:42 -0800</pubDate><guid>https://blog.litsynp.com/posts/2022/01/07/tir-redis-vs-kafka-vs-rabbitmq/</guid><description>Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec
What I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages</description></item><item><title>[DRF] Serializer에 writable non-model field 추가하기</title><link>https://blog.litsynp.com/posts/2021/01/05/drf-serializer%EC%97%90-writable-non-model-field-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 05 Jan 2022 23:31:28 -0800</pubDate><guid>https://blog.litsynp.com/posts/2021/01/05/drf-serializer%EC%97%90-writable-non-model-field-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/</guid><description>문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.
해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.
class UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (&amp;#39;id&amp;#39;, &amp;#39;username&amp;#39;, &amp;#39;password&amp;#39;, &amp;#39;non_model_field&amp;#39;) def validate(self, attrs): # ... attrs.pop(&amp;#39;non_model_field&amp;#39;, None) return super().validate(attrs) REF Stack Overflow</description></item><item><title>Spring Boot에서 Swagger UI 접속이 안되는 경우</title><link>https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link><pubDate>Sun, 05 Sep 2021 01:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid><description>문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.
원인 아마도 dependencies를 잘못 설정했을 확률이 높다.
해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,
implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger-ui&amp;#39;, version: &amp;#39;3.0.0&amp;#39; implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger2&amp;#39;, version: &amp;#39;3.0.0&amp;#39; 다음과 같이 바꾼다.
implementation &amp;#34;io.springfox:springfox-boot-starter:3.0.0&amp;#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍</description></item><item><title>Getting Ambiguous @ExceptionHandler method mapped for XXXException</title><link>https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-exceptionhandler-method-mapped-for-xxxexception/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-exceptionhandler-method-mapped-for-xxxexception/</guid><description>문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,
Getting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.
원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.
해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)
REF Stack Overflow</description></item><item><title>[Python] super() 이용해서 기존 메소드 이용하기</title><link>https://blog.litsynp.com/posts/2021/02/10/python-super-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B8%B0%EC%A1%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021/02/10/python-super-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B8%B0%EC%A1%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description>Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.
그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.
예시는 다음과 같다.
# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(&amp;#39;pk&amp;#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { &amp;#39;detail&amp;#39;: &amp;#39;Delete function is not offered without authorization as the owner.</description></item></channel></rss>