<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on litsynp.log</title>
    <link>https://blog.litsynp.com/tags/java/</link>
    <description>Recent content in Java on litsynp.log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© [litsynp](https://github.com/litsynp).</copyright>
    <lastBuildDate>Sat, 12 Feb 2022 11:28:52 -0800</lastBuildDate><atom:link href="https://blog.litsynp.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Java] Garbage Collector in JVM</title>
      <link>https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/</link>
      <pubDate>Sat, 12 Feb 2022 11:28:52 -0800</pubDate>
      
      <guid>https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/</guid>
      <description>Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, &amp;hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.</description>
    </item>
    
  </channel>
</rss>
