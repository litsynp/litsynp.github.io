<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">
    <title>Spring Batch와 주요 클래스 정리</title>

    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

    <!-- Highlight.js Copy -->
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css">

    <script>
      hljs.highlightAll();
      hljs.addPlugin(new CopyButtonPlugin());
    </script>

  </head>

  <body>
    <div class="wrapper-without-footer">
      <header class="header">
        <center>
          <div class="header-inner-container">
            <a href="/">litsynp.log</a>
            <hr>
            <nav>
              <a href="/">About</a>
              <a href="/posts">Posts</a>
            </nav>
          </div>
        </center>
      </header>

      <main>
        <h1>배치 개발 시나리오</h1>
<p>배치의 일반적인 시나리오는 <strong>읽기</strong> - <strong>처리</strong> - <strong>쓰기</strong>로 나누어진다.</p>
<h1>배치 관련 객체 관계도</h1>
<p><picture><source type="image/webp" srcset="/posts/2022/06/04/spring-batch-summary/myFQEXcr8e-924.webp 924w" sizes="auto"><img loading="lazy" decoding="async" src="/posts/2022/06/04/spring-batch-summary/myFQEXcr8e-924.jpeg" alt="Spring Batch Class Relationship" width="924" height="545"></picture></p>
<p><code>Job</code>과 <code>Step</code>은 <strong>1:M</strong>, <code>Step</code>과 <code>ItemReader</code>, <code>ItemProcessor</code>, <code>ItemWriter</code>는 <strong>1:1 관계</strong>를 갖는다.</p>
<p><code>Job</code>이라는 하나의 큰 일감(<code>Job</code>)에 여러 단계(<code>Step</code>)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.</p>
<h1>배치 관련 클래스 정의</h1>
<h2>Job</h2>
<p><code>Job</code> 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. <code>Job</code> 객체는 여러 <code>Step</code> 인스턴스를 포함하는 컨테이너다.</p>
<p><code>Job</code> 객체를 만드는 빌더는 여러 개가 있다. <code>JobBuilderFactory</code>로 원하는 <code>Job</code>을 만들 수 있다. <code>JobBuilderFactory</code>의 <code>get()</code> 메서드로 <code>JobBuilder</code>를 생성하고 이를 응용하면 된다. <code>org.springframework.batch.core.Configuration.annotation.JobBuilderFactory</code>의 내부 코드이다. (길다 길어!)</p>
<pre><code class="language-java">// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory
public class JobBuilderFactory {
	private JobRepository jobRepository;

	public JobBuilderFactory(JobRepository jobRepository) {
			this.jobRepository = jobRepository;
	}

	public JobBuilder get(String name) {
			JobBuilder builder = new JobBuilder(name).repository(jobRepository);
			return builder;
	}
}
</code></pre>
<p><code>get()</code> 메서드를 호출할 때마다 새로운 <code>JobBuilder</code> 인스턴스를 반환한다. 그리고 매번 생성할 때마다 <code>JobBuilderFactory</code> 를 생성할 때 주입받은 <code>JobRepository</code> 를 사용할 repository로 설정한다. 즉, 해당 <code>JobBuilderFactory</code> 에서 생성되는 모든 <code>JobBuilder</code> 가 동일한 리포지토리를 사용한다.</p>
<p>아래는 <code>JobBuilder</code> 코드 일부이다.</p>
<pre><code class="language-java">// org.springframework.batch.core.job.builder.JobBuilder

// ...

public SimpleJobBuilder start(Step step) {
	return new SimpleJobBuilder(this).start(step);
}

public JobFlowBuilder start(Flow flow) {
	return new JobFlowBuilder(this).start(flow);
}

public JobFlowBuilder flow(Step step) {
	return new JobFlowBuilder(this).start(step);
}

// ...
</code></pre>
<p>공통점은 모두 빌더를 반환한다는 점이다. <code>JobBuilder</code>은 <code>Job</code>을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 <code>Job</code> 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 <code>Job</code> 생성이 이루어지게 하는 의도로 파악된다.</p>
<p>빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.</p>
<p>메서드를 살펴보면 <code>Job</code>을 생성하기 위한 <code>Step</code> 또는 <code>Flow</code>를 파라미터로 받아 구체적인 빌더를 생성하고 있다. <code>Job</code>은 <code>Step</code> 또는 <code>Flow</code> 인스턴스의 <strong>컨테이너 역할</strong>을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.</p>
<p>다음은 <code>Job</code> 생성 예제 코드이다.</p>
<pre><code class="language-java">@Autowired
private JobBuilderFactory jobBuilderFactory;

@Bean
public Job simpleJob() {
    return jobBuilderFactory.get(&quot;simpleJob&quot;)  // 'simpleJob' 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환
                .start(simpleStep())  // `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder`
                .build();  // 'simpleJob'이라는 이름을 가진 `Job`이 생성되어 반환
}
</code></pre>
<h3>JobInstance</h3>
<p><code>JobInstance</code> 는 배치에서 <code>Job</code> 이 실행될 때 <strong>하나의 <code>Job</code> 실행 단위</strong>이다. 만약 하루에 한 번씩 배치의 <code>Job</code> 이 실행된다면, 어제와 오늘 실행한 각각의 <code>Job</code>을 <code>JobInstance</code> 라고 부를 수 있다.</p>
<p>그렇다면 각각의 <code>JobInstance</code> 는 하나의 <code>JobExecution</code> (<code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.</p>
<p>오늘 <code>Job</code>을 실행했는데 실패했다면 다음날 <strong>동일한 <code>JobInstance</code> 를 가지고 또 실행</strong>한다. <code>Job</code> 실행이 실패하면 <code>JobInstance</code> 가 끝난 것으로 간주하지 않기 때문이다.</p>
<p>그러면 <code>JobInstance</code> 는 <strong>어제의 실패한 <code>JobExecution</code> 과 오늘 성공한 <code>JobExecution</code> 두 개</strong>를 갖게 된다. 즉, <strong><code>JobExecution</code>을 여러 개 가질 수 있다.</strong></p>
<h3>JobExecution</h3>
<p><code>JobExecution</code> 은 <code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체이다.</p>
<p>위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 <code>Job</code>이 실패해 내일 다시 동일한 <code>Job</code> 을 실행하면 오늘, 내일의 실행 모두 같은 <code>JobInstance</code> 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 <code>JobExecution</code> 을 생성한다.</p>
<p><code>JobExecution</code> 인터페이스를 보면 <code>Job</code> 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. <code>JobExecution</code> 은 <code>JobInstance</code>, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.</p>
<p>다음은 <code>JobExecution</code> 내부의 코드이다.</p>
<pre><code class="language-java">// org.springframework.batch.core.JobExecution
public class JobExecution extends Entity {

	private final JobParameters jobParameters;
	private JobInstance jobInstance;
	private volatile Collection&lt;StepExecution&gt; stepExecutions = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;());
	private volatile BatchStatus status = BatchStatus.STARTING;
	private volatile Date startTime = null;
	private volatile Date createTime = new Date(System.currentTimeMillis());
	private volatile Date endTime = null;
	private volatile Date lastUpdated = null;
	private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN;
	private volatile ExecutionContext executionContext = new ExecutionContext();
	private transient volatile List&lt;Throwable&gt; failureExceptions = new CopyOnWriteArrayList&lt;&gt;();
	private final String jobConfigurationName;

		// ...
}
</code></pre>
<ul>
<li><code>jobParameters</code> : <code>Job</code> 실행에 필요한 매개변수 데이터.</li>
<li><code>jobInstance</code> : <code>Job</code> 실행의 단위가 되는 객체.</li>
<li><code>stepExecutions</code> : <code>StepExecution</code>을 여러 개 가질 수 있는 Collection 타입.</li>
<li><code>status</code> : <code>Job</code>의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>)</li>
<li><code>startTime</code> : <code>Job</code> 이 실행된 시간. <code>null</code> 이면 시작하지 않았다는 뜻.</li>
<li><code>createTime</code> : <code>JobExecution</code> 이 생성된 시간.</li>
<li><code>endTime</code> : <code>JobExecution</code>이 끝난 시간.</li>
<li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li>
<li><code>exitStatus</code> : <code>Job</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>)</li>
<li><code>executionContext</code> : <code>Job</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li>
<li><code>failureExceptions</code> : <code>Job</code> <strong>실행 중 발생한 예외</strong>를 <code>List</code> 에 넣어둔다.</li>
<li><code>jobConfigurationName</code> : <code>Job</code> 설정 이름.</li>
</ul>
<h3>JobParameters</h3>
<p><code>JobParameters</code> 는 <strong><code>Job</code> 이 실행될 때 필요한 파라미터</strong>들을 <code>Map</code> 타입으로 저장하는 객체이다.</p>
<p><code>JobParameters</code> 는 <strong><code>JobInstance</code> 를 구분하는 기준</strong>이 되기도 한다. 예를 들어 <code>Job</code> 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 <code>JobInstance</code> 를 생성한다.</p>
<p>즉, <code>JobInstance</code>와 <code>JobParameters</code> 는 1:1 관계이다. 파라미터의 타입으로는 <code>String</code> , <code>Long</code> , <code>Date</code> , <code>Double</code> 을 사용할 수 있다.</p>
<h2>Step</h2>
<p><code>Step</code>은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. <strong><code>Job</code> 을 처리하는 실질적인 단위</strong>로 쓰인다.</p>
<p><strong>모든 <code>Job</code> 에는 1개 이상의 <code>Step</code>이 있어야 한다.</strong></p>
<h3>StepExecution</h3>
<p><code>Job</code> 에 <code>JobExecution</code> 이라는 <code>Job</code> 실행 정보가 있다면, <code>Step</code>에는 <code>StepExecution</code> 이라는 <code>Step</code> 실행 정보를 담는 객체가 있다. 각각의 <code>Step</code> 이 실행될 때마다 <code>StepExecution</code> 이 생성된다.</p>
<p>다음은 <code>StepExecution</code> 클래스이다.</p>
<pre><code class="language-java">public class StepExecution extends Entity {

	private final JobExecution jobExecution;
	private final String stepName;
	private volatile BatchStatus status = BatchStatus.STARTING;
	private volatile long readCount = 0;
	private volatile long writeCount = 0;
	private volatile long commitCount = 0;
	private volatile long rollbackCount = 0;
	private volatile long readSkipCount = 0;
	private volatile long processSkipCount = 0;
	private volatile long writeSkipCount = 0;
	private volatile Date startTime = null;
	private volatile Date createTime = new Date(System.currentTimeMillis());
	private volatile Date endTime = null;
	private volatile Date lastUpdated = null;
	private volatile ExecutionContext executionContext = new ExecutionContext();
	private volatile ExitStatus exitStatus = ExitStatus.EXECUTING;
	private volatile boolean terminateOnly;
	private volatile long filterCount;
	private transient volatile List&lt;Throwable&gt; failureExceptions = new CopyOnWriteArrayList&lt;&gt;();

	// ...
}
</code></pre>
<ul>
<li><code>jobExecution</code> : 현재의 <code>JobExecution</code> 정보.</li>
<li><code>stepName</code> : <code>Step</code>의 이름.</li>
<li><code>status</code> : <code>Step</code> 의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>.)</li>
<li><code>readCount</code> : 성공적으로 <strong>읽은 레코드 수</strong>.</li>
<li><code>writeCount</code> : 성공적으로 <strong>쓴 레코드 수</strong>.</li>
<li><code>commitCount</code> : <code>Step</code>의 실행에 대해 <strong>커밋된 트랜잭션 수</strong>.</li>
<li><code>rollbackCount</code> : <code>Step</code>의 실행에 대해 <strong>롤백된 트랜잭션 수</strong>.</li>
<li><code>readSkipCount</code> : 읽기에 실패해 건너뛴 레코드 수.</li>
<li><code>processSkipCount</code> : 프로세스가 실패해 건너뛴 레코드 수.</li>
<li><code>writeSkipCount</code> : 쓰기에 실패해 건너뛴 레코드 수.</li>
<li><code>startTime</code> : <code>Step</code>이 실행된 시간. <code>null</code>이면 시작하지 않았다는 뜻.</li>
<li><code>endTime</code> : <code>Step</code>의 <strong>실행 성공 여부와 관련 없이</strong> <code>Step</code>이 끝난 시간.</li>
<li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li>
<li><code>executionContext</code> : <code>Step</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li>
<li><code>exitStatus</code> : <code>Step</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>.)</li>
<li><code>terminateOnly</code> : <code>Job</code> 실행 중지 여부.</li>
<li><code>filterCount</code> : 실행에서 필터링된 레코드 수.</li>
<li><code>failureExceptions</code> : <code>Step</code> 실행 중 발생한 예외를 <code>List</code> 타입으로 저장한다.</li>
</ul>
<h2>JobRepository</h2>
<p><code>JobRepository</code> 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 <code>Job</code>이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 <strong>배치 처리에 대한 메타데이터를 저장</strong>한다.</p>
<p>예를 들어 <code>Job</code> 하나가 실행되면 <code>JobRepository</code> 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 <code>JobExecution</code> 을 생성한다.</p>
<p><code>JobRepository</code> 는 <code>Step</code> 의 실행 정보를 담고 있는 <code>StepExecution</code> 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.</p>
<h2>JobLauncher</h2>
<p><code>JobLauncher</code> 는 <code>Job</code> , <code>JobParameters</code> 와 함께 <strong>배치를 실행하는 인터페이스</strong>이다. 인터페이스는 <code>run()</code> 하나이다.</p>
<pre><code class="language-java">// org.springframework.batch.core.launch.JobLauncher
public interface JobLauncher {
	public JobExecution run(Job job, JobParameters jobParameters) throws ...
}
</code></pre>
<p>매개변수로 <code>Job</code>과 <code>JobParameters</code>를 받아 <code>JobExecution</code>을 반환한다. <strong>매개변수가 이전과 동일하면서 이전에 <code>JobExecution</code>이 중단된 적 있다면 동일한 <code>JobExecution</code>을 반환</strong>한다.</p>
<h2>ItemReader</h2>
<p><code>ItemReader</code>는 <code>Step</code>의 대상이 되는 <strong>배치 데이터를 읽어오는 인터페이스</strong>이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.</p>
<pre><code class="language-java">// org.springframework.batch.item.ItemReader
public interface ItemReader&lt;T&gt; {
	T read() throws Exception, UnexpectedException, ParseException, NonTransientResourceException;
}
</code></pre>
<p><code>ItemReader</code> 에서 <code>read()</code> 메서드의 반환 타입을 제네릭 <code>&lt;T&gt;</code> 으로 구성했기 때문에 직접 타입을 지정할 수 있다.</p>
<p>위에서 설명한 <em>읽기-처리-쓰기</em>에서 <strong>읽기를 담당</strong>한다고 볼 수 있겠다!</p>
<h2>ItemProcessor</h2>
<p><code>ItemProcessor</code> 는 <code>ItemReader</code> 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.</p>
<p><em>읽기-처리-쓰기</em> 에서 <strong>처리를 담당</strong>한다고 볼 수 있겠다.</p>
<p>굳이 <code>ItemWriter</code>가 아니라 <code>ItemProcessor</code>라는 인터페이스를 분리한 이유는 두 가지다.</p>
<ol>
<li>비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다.</li>
<li>Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 <code>&lt;I, O&gt;</code>에 들어가게 되니 더 직관적이다.</li>
</ol>
<pre><code class="language-java">// org.springframework.batch.item.ItemProcesor
public interface ItemProcessor&lt;I, O&gt; {
	O process(I item) throws Exception;
}
</code></pre>
<h2>ItemWriter</h2>
<p><code>ItemWriter</code> 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.</p>
<p>읽기-처리-쓰기에서 마지막 단계인 <strong>쓰기를 담당</strong>한다.</p>
<pre><code class="language-java">// org.springframework.batch.item.ItemWriter
public interface ItemWriter&lt;T&gt; {
	void write(List&lt;? extends T&gt; items) throws Exception;
}
</code></pre>
<p><code>ItemWriter</code>은 <code>ItemReader</code>와 비슷한 방식으로 구현하면 된다.</p>
<p><code>write()</code> 메서드는 <code>List</code> 자료구조를 이용해 <strong>지정한 타입의 리스트</strong>를 매개변수를 받는다. 리스트의 데이터 수는 설정한 <strong>청크 (chunk) 단위</strong>로 불러온다.</p>
<p><code>write()</code> 메서드는 <code>void</code> 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.</p>
<h1>REF</h1>
<ul>
<li>
<p><a href="http://www.yes24.com/Product/Goods/64584833">&lt;처음 배우는 스프링 부트 2&gt; - 김영재 저</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-batch">GitHub - spring-batch</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-batch">Spring Doc - Spring Batch</a></p>
</li>
</ul>

      </main>
    </div>

    <footer>
      <center>
        <div class="footer-inner-container">
          <hr>
          <p>© litsynp.log</p>
        </div>
      </center>
    </footer>
  </body>
</html>