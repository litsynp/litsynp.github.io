<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring Batch와 주요 클래스 정리 | litsynp.log</title><meta name=keywords content="Spring,Spring Batch"><meta name=description content="배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다."><meta name=author content="litsynp"><link rel=canonical href=https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.litsynp.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.litsynp.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.litsynp.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.litsynp.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.litsynp.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=keywords content="programming,development,web,fullstack,backend,frontend,microservices,infrastructure"><meta property="og:site_name" content="litsynp.log"><meta property="og:title" content="litsynp.log"><meta name=theme-color content="#141414"><title>Spring Batch와 주요 클래스 정리 | litsynp.log</title><meta property="og:type" content="article"><meta property="og:title" content="Spring Batch와 주요 클래스 정리"><meta property="og:description" content="배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다."><meta name=description content="배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다."><meta property="article:author" content="litsynp"><meta property="article:published_time" content="2022-06-04 23:55:52 +0900 +0900"><script async src="https://www.googletagmanager.com/gtag/js?id=G-KNPB15W2HP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-KNPB15W2HP',{anonymize_ip:!1})}</script><meta property="og:title" content="Spring Batch와 주요 클래스 정리"><meta property="og:description" content="배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/"><meta property="og:image" content="https://user-images.githubusercontent.com/42485462/172010391-6e903327-fcce-4eb8-8610-5ddc51767735.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-04T23:55:52+09:00"><meta property="article:modified_time" content="2022-06-04T23:55:52+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/42485462/172010391-6e903327-fcce-4eb8-8610-5ddc51767735.png"><meta name=twitter:title content="Spring Batch와 주요 클래스 정리"><meta name=twitter:description content="배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.
배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.
Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.
배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.
Job 객체를 만드는 빌더는 여러 개가 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.litsynp.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring Batch와 주요 클래스 정리","item":"https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring Batch와 주요 클래스 정리","name":"Spring Batch와 주요 클래스 정리","description":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다.","keywords":["Spring","Spring Batch"],"articleBody":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다. JobBuilderFactory로 원하는 Job을 만들 수 있다. JobBuilderFactory의 get() 메서드로 JobBuilder를 생성하고 이를 응용하면 된다. org.springframework.batch.core.Configuration.annotation.JobBuilderFactory의 내부 코드이다. (길다 길어!)\n// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory public class JobBuilderFactory { private JobRepository jobRepository; public JobBuilderFactory(JobRepository jobRepository) { this.jobRepository = jobRepository; } public JobBuilder get(String name) { JobBuilder builder = new JobBuilder(name).repository(jobRepository); return builder; } } get() 메서드를 호출할 때마다 새로운 JobBuilder 인스턴스를 반환한다. 그리고 매번 생성할 때마다 JobBuilderFactory 를 생성할 때 주입받은 JobRepository 를 사용할 repository로 설정한다. 즉, 해당 JobBuilderFactory 에서 생성되는 모든 JobBuilder 가 동일한 리포지토리를 사용한다.\n아래는 JobBuilder 코드 일부이다.\n// org.springframework.batch.core.job.builder.JobBuilder // ... public SimpleJobBuilder start(Step step) { return new SimpleJobBuilder(this).start(step); } public JobFlowBuilder start(Flow flow) { return new JobFlowBuilder(this).start(flow); } public JobFlowBuilder flow(Step step) { return new JobFlowBuilder(this).start(step); } // ... 공통점은 모두 빌더를 반환한다는 점이다. JobBuilder은 Job을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 Job 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 Job 생성이 이루어지게 하는 의도로 파악된다.\n빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.\n메서드를 살펴보면 Job을 생성하기 위한 Step 또는 Flow를 파라미터로 받아 구체적인 빌더를 생성하고 있다. Job은 Step 또는 Flow 인스턴스의 컨테이너 역할을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.\n다음은 Job 생성 예제 코드이다.\n@Autowired private JobBuilderFactory jobBuilderFactory; @Bean public Job simpleJob() { return jobBuilderFactory.get(\"simpleJob\") // 'simpleJob' 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환 .start(simpleStep()) // `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder` .build(); // 'simpleJob'이라는 이름을 가진 `Job`이 생성되어 반환 } JobInstance JobInstance 는 배치에서 Job 이 실행될 때 하나의 Job 실행 단위이다. 만약 하루에 한 번씩 배치의 Job 이 실행된다면, 어제와 오늘 실행한 각각의 Job을 JobInstance 라고 부를 수 있다.\n그렇다면 각각의 JobInstance 는 하나의 JobExecution (JobInstance에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.\n오늘 Job을 실행했는데 실패했다면 다음날 동일한 JobInstance 를 가지고 또 실행한다. Job 실행이 실패하면 JobInstance 가 끝난 것으로 간주하지 않기 때문이다.\n그러면 JobInstance 는 어제의 실패한 JobExecution 과 오늘 성공한 JobExecution 두 개를 갖게 된다. 즉, JobExecution을 여러 개 가질 수 있다.\nJobExecution JobExecution 은 JobInstance에 대한 한 번의 실행을 나타내는 객체이다.\n위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 Job이 실패해 내일 다시 동일한 Job 을 실행하면 오늘, 내일의 실행 모두 같은 JobInstance 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 JobExecution 을 생성한다.\nJobExecution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. JobExecution 은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.\n다음은 JobExecution 내부의 코드이다.\n// org.springframework.batch.core.JobExecution public class JobExecution extends Entity { private final JobParameters jobParameters; private JobInstance jobInstance; private volatile Collection\u003cStepExecution\u003e stepExecutions = Collections.synchronizedSet(new LinkedHashSet\u003c\u003e()); private volatile BatchStatus status = BatchStatus.STARTING; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN; private volatile ExecutionContext executionContext = new ExecutionContext(); private transient volatile List\u003cThrowable\u003e failureExceptions = new CopyOnWriteArrayList\u003c\u003e(); private final String jobConfigurationName; // ... } jobParameters : Job 실행에 필요한 매개변수 데이터. jobInstance : Job 실행의 단위가 되는 객체. stepExecutions : StepExecution을 여러 개 가질 수 있는 Collection 타입. status : Job의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING) startTime : Job 이 실행된 시간. null 이면 시작하지 않았다는 뜻. createTime : JobExecution 이 생성된 시간. endTime : JobExecution이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. exitStatus : Job 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN) executionContext : Job 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. failureExceptions : Job 실행 중 발생한 예외를 List 에 넣어둔다. jobConfigurationName : Job 설정 이름. JobParameters JobParameters 는 Job 이 실행될 때 필요한 파라미터들을 Map 타입으로 저장하는 객체이다.\nJobParameters 는 JobInstance 를 구분하는 기준이 되기도 한다. 예를 들어 Job 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 JobInstance 를 생성한다.\n즉, JobInstance와 JobParameters 는 1:1 관계이다. 파라미터의 타입으로는 String , Long , Date , Double 을 사용할 수 있다.\nStep Step은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. Job 을 처리하는 실질적인 단위로 쓰인다.\n모든 Job 에는 1개 이상의 Step이 있어야 한다.\nStepExecution Job 에 JobExecution 이라는 Job 실행 정보가 있다면, Step에는 StepExecution 이라는 Step 실행 정보를 담는 객체가 있다. 각각의 Step 이 실행될 때마다 StepExecution 이 생성된다.\n다음은 StepExecution 클래스이다.\npublic class StepExecution extends Entity { private final JobExecution jobExecution; private final String stepName; private volatile BatchStatus status = BatchStatus.STARTING; private volatile long readCount = 0; private volatile long writeCount = 0; private volatile long commitCount = 0; private volatile long rollbackCount = 0; private volatile long readSkipCount = 0; private volatile long processSkipCount = 0; private volatile long writeSkipCount = 0; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExecutionContext executionContext = new ExecutionContext(); private volatile ExitStatus exitStatus = ExitStatus.EXECUTING; private volatile boolean terminateOnly; private volatile long filterCount; private transient volatile List\u003cThrowable\u003e failureExceptions = new CopyOnWriteArrayList\u003c\u003e(); // ... } jobExecution : 현재의 JobExecution 정보. stepName : Step의 이름. status : Step 의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING.) readCount : 성공적으로 읽은 레코드 수. writeCount : 성공적으로 쓴 레코드 수. commitCount : Step의 실행에 대해 커밋된 트랜잭션 수. rollbackCount : Step의 실행에 대해 롤백된 트랜잭션 수. readSkipCount : 읽기에 실패해 건너뛴 레코드 수. processSkipCount : 프로세스가 실패해 건너뛴 레코드 수. writeSkipCount : 쓰기에 실패해 건너뛴 레코드 수. startTime : Step이 실행된 시간. null이면 시작하지 않았다는 뜻. endTime : Step의 실행 성공 여부와 관련 없이 Step이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. executionContext : Step 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. exitStatus : Step 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN.) terminateOnly : Job 실행 중지 여부. filterCount : 실행에서 필터링된 레코드 수. failureExceptions : Step 실행 중 발생한 예외를 List 타입으로 저장한다. JobRepository JobRepository 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 Job이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장한다.\n예를 들어 Job 하나가 실행되면 JobRepository 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 JobExecution 을 생성한다.\nJobRepository 는 Step 의 실행 정보를 담고 있는 StepExecution 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.\nJobLauncher JobLauncher 는 Job , JobParameters 와 함께 배치를 실행하는 인터페이스이다. 인터페이스는 run() 하나이다.\n// org.springframework.batch.core.launch.JobLauncher public interface JobLauncher { public JobExecution run(Job job, JobParameters jobParameters) throws ... } 매개변수로 Job과 JobParameters를 받아 JobExecution을 반환한다. 매개변수가 이전과 동일하면서 이전에 JobExecution이 중단된 적 있다면 동일한 JobExecution을 반환한다.\nItemReader ItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.\n// org.springframework.batch.item.ItemReader public interface ItemReader\u003cT\u003e { T read() throws Exception, UnexpectedException, ParseException, NonTransientResourceException; } ItemReader 에서 read() 메서드의 반환 타입을 제네릭 으로 구성했기 때문에 직접 타입을 지정할 수 있다.\n위에서 설명한 읽기-처리-쓰기에서 읽기를 담당한다고 볼 수 있겠다!\nItemProcessor ItemProcessor 는 ItemReader 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.\n읽기-처리-쓰기 에서 처리를 담당한다고 볼 수 있겠다.\n굳이 ItemWriter가 아니라 ItemProcessor라는 인터페이스를 분리한 이유는 두 가지다.\n비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다. Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 에 들어가게 되니 더 직관적이다. // org.springframework.batch.item.ItemProcesor public interface ItemProcessor\u003cI, O\u003e { O process(I item) throws Exception; } ItemWriter ItemWriter 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.\n읽기-처리-쓰기에서 마지막 단계인 쓰기를 담당한다.\n// org.springframework.batch.item.ItemWriter public interface ItemWriter\u003cT\u003e { void write(List\u003c? extends T\u003e items) throws Exception; } ItemWriter은 ItemReader와 비슷한 방식으로 구현하면 된다.\nwrite() 메서드는 List 자료구조를 이용해 지정한 타입의 리스트를 매개변수를 받는다. 리스트의 데이터 수는 설정한 청크 (chunk) 단위로 불러온다.\nwrite() 메서드는 void 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.\nREF \u003c처음 배우는 스프링 부트 2\u003e - 김영재 저\nGitHub - spring-batch\nSpring Doc - Spring Batch\n","wordCount":"1398","inLanguage":"en","image":"https://user-images.githubusercontent.com/42485462/172010391-6e903327-fcce-4eb8-8610-5ddc51767735.png","datePublished":"2022-06-04T23:55:52+09:00","dateModified":"2022-06-04T23:55:52+09:00","author":{"@type":"Person","name":"litsynp"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/"},"publisher":{"@type":"Organization","name":"litsynp.log","logo":{"@type":"ImageObject","url":"https://blog.litsynp.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://blog.litsynp.com/ accesskey=h title="litsynp.log (Alt + H)">litsynp.log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.litsynp.com/posts title=posts><span>posts</span></a></li><li><a href=https://blog.litsynp.com/search title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.litsynp.com/archives title=archives><span>archives</span></a></li><li><a href=https://blog.litsynp.com/tags title=tags><span>tags</span></a></li><li><a href=https://blog.litsynp.com/categories title=categories><span>categories</span></a></li><li><a href=https://blog.litsynp.com/series title=series><span>series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.litsynp.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.litsynp.com/posts/>Posts</a></div><h1 class=post-title>Spring Batch와 주요 클래스 정리</h1><div class=post-meta><span title='2022-06-04 23:55:52 +0900 +0900'>June 4, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;litsynp&nbsp;|&nbsp;<a href=https://github.com/litsynp/litsynp.github.io/blob/main/content/posts/2022/06/04/spring-batch-summary.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://user-images.githubusercontent.com/42485462/172010391-6e903327-fcce-4eb8-8610-5ddc51767735.png alt="Spring Batch"><p>Spring Batch</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%b0%b0%ec%b9%98-%ea%b0%9c%eb%b0%9c-%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4 aria-label="배치 개발 시나리오">배치 개발 시나리오</a></li><li><a href=#%eb%b0%b0%ec%b9%98-%ea%b4%80%eb%a0%a8-%ea%b0%9d%ec%b2%b4-%ea%b4%80%ea%b3%84%eb%8f%84 aria-label="배치 관련 객체 관계도">배치 관련 객체 관계도</a></li><li><a href=#%eb%b0%b0%ec%b9%98-%ea%b4%80%eb%a0%a8-%ed%81%b4%eb%9e%98%ec%8a%a4-%ec%a0%95%ec%9d%98 aria-label="배치 관련 클래스 정의">배치 관련 클래스 정의</a><ul><li><a href=#job aria-label=Job>Job</a><ul><li><a href=#jobinstance aria-label=JobInstance>JobInstance</a></li><li><a href=#jobexecution aria-label=JobExecution>JobExecution</a></li><li><a href=#jobparameters aria-label=JobParameters>JobParameters</a></li></ul></li><li><a href=#step aria-label=Step>Step</a><ul><li><a href=#stepexecution aria-label=StepExecution>StepExecution</a></li></ul></li><li><a href=#jobrepository aria-label=JobRepository>JobRepository</a></li><li><a href=#joblauncher aria-label=JobLauncher>JobLauncher</a></li><li><a href=#itemreader aria-label=ItemReader>ItemReader</a></li><li><a href=#itemprocessor aria-label=ItemProcessor>ItemProcessor</a></li><li><a href=#itemwriter aria-label=ItemWriter>ItemWriter</a></li></ul></li><li><a href=#ref aria-label=REF>REF</a></li></ul></div></details></div><div class=post-content><h1 id=배치-개발-시나리오>배치 개발 시나리오<a hidden class=anchor aria-hidden=true href=#배치-개발-시나리오>#</a></h1><p>배치의 일반적인 시나리오는 <strong>읽기</strong> - <strong>처리</strong> - <strong>쓰기</strong>로 나누어진다.</p><h1 id=배치-관련-객체-관계도>배치 관련 객체 관계도<a hidden class=anchor aria-hidden=true href=#배치-관련-객체-관계도>#</a></h1><p><img loading=lazy src=https://docs.spring.io/spring-batch/docs/current/reference/html/images/spring-batch-reference-model.png alt="Spring Batch Class Relationship"></p><p><code>Job</code>과 <code>Step</code>은 <strong>1:M</strong>, <code>Step</code>과 <code>ItemReader</code>, <code>ItemProcessor</code>, <code>ItemWriter</code>는 <strong>1:1 관계</strong>를 갖는다.</p><p><code>Job</code>이라는 하나의 큰 일감(<code>Job</code>)에 여러 단계(<code>Step</code>)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.</p><h1 id=배치-관련-클래스-정의>배치 관련 클래스 정의<a hidden class=anchor aria-hidden=true href=#배치-관련-클래스-정의>#</a></h1><h2 id=job>Job<a hidden class=anchor aria-hidden=true href=#job>#</a></h2><p><code>Job</code> 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. <code>Job</code> 객체는 여러 <code>Step</code> 인스턴스를 포함하는 컨테이너다.</p><p><code>Job</code> 객체를 만드는 빌더는 여러 개가 있다. <code>JobBuilderFactory</code>로 원하는 <code>Job</code>을 만들 수 있다. <code>JobBuilderFactory</code>의 <code>get()</code> 메서드로 <code>JobBuilder</code>를 생성하고 이를 응용하면 된다. <code>org.springframework.batch.core.Configuration.annotation.JobBuilderFactory</code>의 내부 코드이다. (길다 길어!)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobBuilderFactory</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> JobRepository jobRepository<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>JobBuilderFactory</span><span style=color:#f92672>(</span>JobRepository jobRepository<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>jobRepository</span> <span style=color:#f92672>=</span> jobRepository<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobBuilder <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>			JobBuilder builder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JobBuilder<span style=color:#f92672>(</span>name<span style=color:#f92672>).</span><span style=color:#a6e22e>repository</span><span style=color:#f92672>(</span>jobRepository<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> builder<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><code>get()</code> 메서드를 호출할 때마다 새로운 <code>JobBuilder</code> 인스턴스를 반환한다. 그리고 매번 생성할 때마다 <code>JobBuilderFactory</code> 를 생성할 때 주입받은 <code>JobRepository</code> 를 사용할 repository로 설정한다. 즉, 해당 <code>JobBuilderFactory</code> 에서 생성되는 모든 <code>JobBuilder</code> 가 동일한 리포지토리를 사용한다.</p><p>아래는 <code>JobBuilder</code> 코드 일부이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.job.builder.JobBuilder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> SimpleJobBuilder <span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>Step step<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SimpleJobBuilder<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>step<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JobFlowBuilder <span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>Flow flow<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JobFlowBuilder<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>flow<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JobFlowBuilder <span style=color:#a6e22e>flow</span><span style=color:#f92672>(</span>Step step<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JobFlowBuilder<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>step<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>공통점은 모두 빌더를 반환한다는 점이다. <code>JobBuilder</code>은 <code>Job</code>을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 <code>Job</code> 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 <code>Job</code> 생성이 이루어지게 하는 의도로 파악된다.</p><p>빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.</p><p>메서드를 살펴보면 <code>Job</code>을 생성하기 위한 <code>Step</code> 또는 <code>Flow</code>를 파라미터로 받아 구체적인 빌더를 생성하고 있다. <code>Job</code>은 <code>Step</code> 또는 <code>Flow</code> 인스턴스의 <strong>컨테이너 역할</strong>을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.</p><p>다음은 <code>Job</code> 생성 예제 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> JobBuilderFactory jobBuilderFactory<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Job <span style=color:#a6e22e>simpleJob</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jobBuilderFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;simpleJob&#34;</span><span style=color:#f92672>)</span>  <span style=color:#75715e>// &#39;simpleJob&#39; 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>simpleStep<span style=color:#f92672>())</span>  <span style=color:#75715e>// `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// &#39;simpleJob&#39;이라는 이름을 가진 `Job`이 생성되어 반환
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=jobinstance>JobInstance<a hidden class=anchor aria-hidden=true href=#jobinstance>#</a></h3><p><code>JobInstance</code> 는 배치에서 <code>Job</code> 이 실행될 때 <strong>하나의 <code>Job</code> 실행 단위</strong>이다. 만약 하루에 한 번씩 배치의 <code>Job</code> 이 실행된다면, 어제와 오늘 실행한 각각의 <code>Job</code>을 <code>JobInstance</code> 라고 부를 수 있다.</p><p>그렇다면 각각의 <code>JobInstance</code> 는 하나의 <code>JobExecution</code> (<code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.</p><p>오늘 <code>Job</code>을 실행했는데 실패했다면 다음날 <strong>동일한 <code>JobInstance</code> 를 가지고 또 실행</strong>한다. <code>Job</code> 실행이 실패하면 <code>JobInstance</code> 가 끝난 것으로 간주하지 않기 때문이다.</p><p>그러면 <code>JobInstance</code> 는 <strong>어제의 실패한 <code>JobExecution</code> 과 오늘 성공한 <code>JobExecution</code> 두 개</strong>를 갖게 된다. 즉, <strong><code>JobExecution</code>을 여러 개 가질 수 있다.</strong></p><h3 id=jobexecution>JobExecution<a hidden class=anchor aria-hidden=true href=#jobexecution>#</a></h3><p><code>JobExecution</code> 은 <code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체이다.</p><p>위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 <code>Job</code>이 실패해 내일 다시 동일한 <code>Job</code> 을 실행하면 오늘, 내일의 실행 모두 같은 <code>JobInstance</code> 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 <code>JobExecution</code> 을 생성한다.</p><p><code>JobExecution</code> 인터페이스를 보면 <code>Job</code> 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. <code>JobExecution</code> 은 <code>JobInstance</code>, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.</p><p>다음은 <code>JobExecution</code> 내부의 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.JobExecution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobExecution</span> <span style=color:#66d9ef>extends</span> Entity <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JobParameters jobParameters<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> JobInstance jobInstance<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Collection<span style=color:#f92672>&lt;</span>StepExecution<span style=color:#f92672>&gt;</span> stepExecutions <span style=color:#f92672>=</span> Collections<span style=color:#f92672>.</span><span style=color:#a6e22e>synchronizedSet</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> LinkedHashSet<span style=color:#f92672>&lt;&gt;());</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> BatchStatus status <span style=color:#f92672>=</span> BatchStatus<span style=color:#f92672>.</span><span style=color:#a6e22e>STARTING</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date startTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date createTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date<span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date endTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date lastUpdated <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExitStatus exitStatus <span style=color:#f92672>=</span> ExitStatus<span style=color:#f92672>.</span><span style=color:#a6e22e>UNKNOWN</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExecutionContext executionContext <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionContext<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> List<span style=color:#f92672>&lt;</span>Throwable<span style=color:#f92672>&gt;</span> failureExceptions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String jobConfigurationName<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li><code>jobParameters</code> : <code>Job</code> 실행에 필요한 매개변수 데이터.</li><li><code>jobInstance</code> : <code>Job</code> 실행의 단위가 되는 객체.</li><li><code>stepExecutions</code> : <code>StepExecution</code>을 여러 개 가질 수 있는 Collection 타입.</li><li><code>status</code> : <code>Job</code>의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>)</li><li><code>startTime</code> : <code>Job</code> 이 실행된 시간. <code>null</code> 이면 시작하지 않았다는 뜻.</li><li><code>createTime</code> : <code>JobExecution</code> 이 생성된 시간.</li><li><code>endTime</code> : <code>JobExecution</code>이 끝난 시간.</li><li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li><li><code>exitStatus</code> : <code>Job</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>)</li><li><code>executionContext</code> : <code>Job</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li><li><code>failureExceptions</code> : <code>Job</code> <strong>실행 중 발생한 예외</strong>를 <code>List</code> 에 넣어둔다.</li><li><code>jobConfigurationName</code> : <code>Job</code> 설정 이름.</li></ul><h3 id=jobparameters>JobParameters<a hidden class=anchor aria-hidden=true href=#jobparameters>#</a></h3><p><code>JobParameters</code> 는 <strong><code>Job</code> 이 실행될 때 필요한 파라미터</strong>들을 <code>Map</code> 타입으로 저장하는 객체이다.</p><p><code>JobParameters</code> 는 <strong><code>JobInstance</code> 를 구분하는 기준</strong>이 되기도 한다. 예를 들어 <code>Job</code> 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 <code>JobInstance</code> 를 생성한다.</p><p>즉, <code>JobInstance</code>와 <code>JobParameters</code> 는 1:1 관계이다. 파라미터의 타입으로는 <code>String</code> , <code>Long</code> , <code>Date</code> , <code>Double</code> 을 사용할 수 있다.</p><h2 id=step>Step<a hidden class=anchor aria-hidden=true href=#step>#</a></h2><p><code>Step</code>은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. <strong><code>Job</code> 을 처리하는 실질적인 단위</strong>로 쓰인다.</p><p><strong>모든 <code>Job</code> 에는 1개 이상의 <code>Step</code>이 있어야 한다.</strong></p><h3 id=stepexecution>StepExecution<a hidden class=anchor aria-hidden=true href=#stepexecution>#</a></h3><p><code>Job</code> 에 <code>JobExecution</code> 이라는 <code>Job</code> 실행 정보가 있다면, <code>Step</code>에는 <code>StepExecution</code> 이라는 <code>Step</code> 실행 정보를 담는 객체가 있다. 각각의 <code>Step</code> 이 실행될 때마다 <code>StepExecution</code> 이 생성된다.</p><p>다음은 <code>StepExecution</code> 클래스이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StepExecution</span> <span style=color:#66d9ef>extends</span> Entity <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JobExecution jobExecution<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String stepName<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> BatchStatus status <span style=color:#f92672>=</span> BatchStatus<span style=color:#f92672>.</span><span style=color:#a6e22e>STARTING</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> readCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> writeCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> commitCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> rollbackCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> readSkipCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> processSkipCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> writeSkipCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date startTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date createTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date<span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>currentTimeMillis</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date endTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date lastUpdated <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExecutionContext executionContext <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionContext<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExitStatus exitStatus <span style=color:#f92672>=</span> ExitStatus<span style=color:#f92672>.</span><span style=color:#a6e22e>EXECUTING</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> terminateOnly<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> filterCount<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> List<span style=color:#f92672>&lt;</span>Throwable<span style=color:#f92672>&gt;</span> failureExceptions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li><code>jobExecution</code> : 현재의 <code>JobExecution</code> 정보.</li><li><code>stepName</code> : <code>Step</code>의 이름.</li><li><code>status</code> : <code>Step</code> 의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>.)</li><li><code>readCount</code> : 성공적으로 <strong>읽은 레코드 수</strong>.</li><li><code>writeCount</code> : 성공적으로 <strong>쓴 레코드 수</strong>.</li><li><code>commitCount</code> : <code>Step</code>의 실행에 대해 <strong>커밋된 트랜잭션 수</strong>.</li><li><code>rollbackCount</code> : <code>Step</code>의 실행에 대해 <strong>롤백된 트랜잭션 수</strong>.</li><li><code>readSkipCount</code> : 읽기에 실패해 건너뛴 레코드 수.</li><li><code>processSkipCount</code> : 프로세스가 실패해 건너뛴 레코드 수.</li><li><code>writeSkipCount</code> : 쓰기에 실패해 건너뛴 레코드 수.</li><li><code>startTime</code> : <code>Step</code>이 실행된 시간. <code>null</code>이면 시작하지 않았다는 뜻.</li><li><code>endTime</code> : <code>Step</code>의 <strong>실행 성공 여부와 관련 없이</strong> <code>Step</code>이 끝난 시간.</li><li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li><li><code>executionContext</code> : <code>Step</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li><li><code>exitStatus</code> : <code>Step</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>.)</li><li><code>terminateOnly</code> : <code>Job</code> 실행 중지 여부.</li><li><code>filterCount</code> : 실행에서 필터링된 레코드 수.</li><li><code>failureExceptions</code> : <code>Step</code> 실행 중 발생한 예외를 <code>List</code> 타입으로 저장한다.</li></ul><h2 id=jobrepository>JobRepository<a hidden class=anchor aria-hidden=true href=#jobrepository>#</a></h2><p><code>JobRepository</code> 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 <code>Job</code>이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 <strong>배치 처리에 대한 메타데이터를 저장</strong>한다.</p><p>예를 들어 <code>Job</code> 하나가 실행되면 <code>JobRepository</code> 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 <code>JobExecution</code> 을 생성한다.</p><p><code>JobRepository</code> 는 <code>Step</code> 의 실행 정보를 담고 있는 <code>StepExecution</code> 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.</p><h2 id=joblauncher>JobLauncher<a hidden class=anchor aria-hidden=true href=#joblauncher>#</a></h2><p><code>JobLauncher</code> 는 <code>Job</code> , <code>JobParameters</code> 와 함께 <strong>배치를 실행하는 인터페이스</strong>이다. 인터페이스는 <code>run()</code> 하나이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.launch.JobLauncher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>JobLauncher</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobExecution <span style=color:#a6e22e>run</span><span style=color:#f92672>(</span>Job job<span style=color:#f92672>,</span> JobParameters jobParameters<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>매개변수로 <code>Job</code>과 <code>JobParameters</code>를 받아 <code>JobExecution</code>을 반환한다. <strong>매개변수가 이전과 동일하면서 이전에 <code>JobExecution</code>이 중단된 적 있다면 동일한 <code>JobExecution</code>을 반환</strong>한다.</p><h2 id=itemreader>ItemReader<a hidden class=anchor aria-hidden=true href=#itemreader>#</a></h2><p><code>ItemReader</code>는 <code>Step</code>의 대상이 되는 <strong>배치 데이터를 읽어오는 인터페이스</strong>이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemReader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemReader</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	T <span style=color:#a6e22e>read</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception<span style=color:#f92672>,</span> UnexpectedException<span style=color:#f92672>,</span> ParseException<span style=color:#f92672>,</span> NonTransientResourceException<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><code>ItemReader</code> 에서 <code>read()</code> 메서드의 반환 타입을 제네릭 <code>&lt;T></code> 으로 구성했기 때문에 직접 타입을 지정할 수 있다.</p><p>위에서 설명한 <em>읽기-처리-쓰기</em>에서 <strong>읽기를 담당</strong>한다고 볼 수 있겠다!</p><h2 id=itemprocessor>ItemProcessor<a hidden class=anchor aria-hidden=true href=#itemprocessor>#</a></h2><p><code>ItemProcessor</code> 는 <code>ItemReader</code> 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.</p><p><em>읽기-처리-쓰기</em> 에서 <strong>처리를 담당</strong>한다고 볼 수 있겠다.</p><p>굳이 <code>ItemWriter</code>가 아니라 <code>ItemProcessor</code>라는 인터페이스를 분리한 이유는 두 가지다.</p><ol><li>비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다.</li><li>Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 <code>&lt;I, O></code>에 들어가게 되니 더 직관적이다.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemProcesor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemProcessor</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>,</span> O<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	O <span style=color:#a6e22e>process</span><span style=color:#f92672>(</span>I item<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=itemwriter>ItemWriter<a hidden class=anchor aria-hidden=true href=#itemwriter>#</a></h2><p><code>ItemWriter</code> 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.</p><p>읽기-처리-쓰기에서 마지막 단계인 <strong>쓰기를 담당</strong>한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemWriter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemWriter</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> items<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><code>ItemWriter</code>은 <code>ItemReader</code>와 비슷한 방식으로 구현하면 된다.</p><p><code>write()</code> 메서드는 <code>List</code> 자료구조를 이용해 <strong>지정한 타입의 리스트</strong>를 매개변수를 받는다. 리스트의 데이터 수는 설정한 <strong>청크 (chunk) 단위</strong>로 불러온다.</p><p><code>write()</code> 메서드는 <code>void</code> 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.</p><h1 id=ref>REF<a hidden class=anchor aria-hidden=true href=#ref>#</a></h1><ul><li><p><a href=http://www.yes24.com/Product/Goods/64584833>&lt;처음 배우는 스프링 부트 2> - 김영재 저</a></p></li><li><p><a href=https://github.com/spring-projects/spring-batch>GitHub - spring-batch</a></p></li><li><p><a href=https://spring.io/projects/spring-batch>Spring Doc - Spring Batch</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.litsynp.com/tags/spring/>Spring</a></li><li><a href=https://blog.litsynp.com/tags/spring-batch/>Spring Batch</a></li></ul><nav class=paginav><a class=prev href=https://blog.litsynp.com/posts/2022/06/05/programmers-q17679-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/><span class=title>« Prev</span><br><span>[프로그래머스][Level 2][#17679] 프렌즈4블록 해설</span></a>
<a class=next href=https://blog.litsynp.com/posts/2022/05/27/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94-the-clean-coder-%EB%8F%85%EC%84%9C-1/><span class=title>Next »</span><br><span>클린 코더 (The Clean Coder) 독서 - 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on twitter" href="https://twitter.com/intent/tweet/?text=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac&url=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f&hashtags=Spring%2cSpringBatch"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f&title=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac&summary=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac&source=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f&title=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on whatsapp" href="https://api.whatsapp.com/send?text=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac%20-%20https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring Batch와 주요 클래스 정리 on telegram" href="https://telegram.me/share/url?text=Spring%20Batch%ec%99%80%20%ec%a3%bc%ec%9a%94%20%ed%81%b4%eb%9e%98%ec%8a%a4%20%ec%a0%95%eb%a6%ac&url=https%3a%2f%2fblog.litsynp.com%2fposts%2f2022%2f06%2f04%2fspring-batch-summary%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://litsynp-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.litsynp.com/>litsynp.log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerHTML='copy';function s(){e.innerHTML='copied!',setTimeout(()=>{e.innerHTML='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>