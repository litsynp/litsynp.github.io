<!doctype html><html lang=en><head><title>Spring Batch와 주요 클래스 정리 &ndash; litsynp.log</title>
<meta name=description content><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin=anonymous><link rel=stylesheet href=https://blog.litsynp.com/css/palettes/base16-dark.css><link rel=stylesheet href=https://blog.litsynp.com/css/risotto.css><link rel=stylesheet href=https://blog.litsynp.com/css/custom.css><link rel=icon href=https://blog.litsynp.com/favicon.ico></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><h1 class=page__logo><a href=https://blog.litsynp.com/ class=page__logo-inner>litsynp.log</a></h1><li class=main-nav__item><a class=nav-main-item href=https://blog.litsynp.com/posts title>posts</a></li><li class=main-nav__item><a class=nav-main-item href=https://blog.litsynp.com/tags title>tags</a></li><li class=main-nav__item><a class=nav-main-item href=https://blog.litsynp.com/categories title>categories</a></li><li class=main-nav__item><a class=nav-main-item href=https://blog.litsynp.com/series title>series</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>Spring Batch와 주요 클래스 정리</h1></header><div class=content__body><h1 id=배치-개발-시나리오>배치 개발 시나리오</h1><p>배치의 일반적인 시나리오는 <strong>읽기</strong> - <strong>처리</strong> - <strong>쓰기</strong>로 나누어진다.</p><h1 id=배치-관련-객체-관계도>배치 관련 객체 관계도</h1><p><img alt="Spring Batch Class Relationship" src=https://docs.spring.io/spring-batch/docs/current/reference/html/images/spring-batch-reference-model.png></p><p><code>Job</code>과 <code>Step</code>은 <strong>1:M</strong>, <code>Step</code>과 <code>ItemReader</code>, <code>ItemProcessor</code>, <code>ItemWriter</code>는 <strong>1:1 관계</strong>를 갖는다.</p><p><code>Job</code>이라는 하나의 큰 일감(<code>Job</code>)에 여러 단계(<code>Step</code>)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.</p><h1 id=배치-관련-클래스-정의>배치 관련 클래스 정의</h1><h2 id=job>Job</h2><p><code>Job</code> 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. <code>Job</code> 객체는 여러 <code>Step</code> 인스턴스를 포함하는 컨테이너다.</p><p><code>Job</code> 객체를 만드는 빌더는 여러 개가 있다. <code>JobBuilderFactory</code>로 원하는 <code>Job</code>을 만들 수 있다. <code>JobBuilderFactory</code>의 <code>get()</code> 메서드로 <code>JobBuilder</code>를 생성하고 이를 응용하면 된다. <code>org.springframework.batch.core.Configuration.annotation.JobBuilderFactory</code>의 내부 코드이다. (길다 길어!)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobBuilderFactory</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> JobRepository jobRepository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>JobBuilderFactory</span>(JobRepository jobRepository) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>jobRepository</span> <span style=color:#f92672>=</span> jobRepository;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobBuilder <span style=color:#a6e22e>get</span>(String name) {
</span></span><span style=display:flex><span>			JobBuilder builder <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JobBuilder(name).<span style=color:#a6e22e>repository</span>(jobRepository);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> builder;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>get()</code> 메서드를 호출할 때마다 새로운 <code>JobBuilder</code> 인스턴스를 반환한다. 그리고 매번 생성할 때마다 <code>JobBuilderFactory</code> 를 생성할 때 주입받은 <code>JobRepository</code> 를 사용할 repository로 설정한다. 즉, 해당 <code>JobBuilderFactory</code> 에서 생성되는 모든 <code>JobBuilder</code> 가 동일한 리포지토리를 사용한다.</p><p>아래는 <code>JobBuilder</code> 코드 일부이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.job.builder.JobBuilder</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> SimpleJobBuilder <span style=color:#a6e22e>start</span>(Step step) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SimpleJobBuilder(<span style=color:#66d9ef>this</span>).<span style=color:#a6e22e>start</span>(step);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JobFlowBuilder <span style=color:#a6e22e>start</span>(Flow flow) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JobFlowBuilder(<span style=color:#66d9ef>this</span>).<span style=color:#a6e22e>start</span>(flow);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JobFlowBuilder <span style=color:#a6e22e>flow</span>(Step step) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JobFlowBuilder(<span style=color:#66d9ef>this</span>).<span style=color:#a6e22e>start</span>(step);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span></code></pre></div><p>공통점은 모두 빌더를 반환한다는 점이다. <code>JobBuilder</code>은 <code>Job</code>을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 <code>Job</code> 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 <code>Job</code> 생성이 이루어지게 하는 의도로 파악된다.</p><p>빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.</p><p>메서드를 살펴보면 <code>Job</code>을 생성하기 위한 <code>Step</code> 또는 <code>Flow</code>를 파라미터로 받아 구체적인 빌더를 생성하고 있다. <code>Job</code>은 <code>Step</code> 또는 <code>Flow</code> 인스턴스의 <strong>컨테이너 역할</strong>을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.</p><p>다음은 <code>Job</code> 생성 예제 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> JobBuilderFactory jobBuilderFactory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Job <span style=color:#a6e22e>simpleJob</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jobBuilderFactory.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;simpleJob&#34;</span>)  <span style=color:#75715e>// &#39;simpleJob&#39; 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>start</span>(simpleStep())  <span style=color:#75715e>// `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder`</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();  <span style=color:#75715e>// &#39;simpleJob&#39;이라는 이름을 가진 `Job`이 생성되어 반환</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=jobinstance>JobInstance</h3><p><code>JobInstance</code> 는 배치에서 <code>Job</code> 이 실행될 때 <strong>하나의 <code>Job</code> 실행 단위</strong>이다. 만약 하루에 한 번씩 배치의 <code>Job</code> 이 실행된다면, 어제와 오늘 실행한 각각의 <code>Job</code>을 <code>JobInstance</code> 라고 부를 수 있다.</p><p>그렇다면 각각의 <code>JobInstance</code> 는 하나의 <code>JobExecution</code> (<code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.</p><p>오늘 <code>Job</code>을 실행했는데 실패했다면 다음날 <strong>동일한 <code>JobInstance</code> 를 가지고 또 실행</strong>한다. <code>Job</code> 실행이 실패하면 <code>JobInstance</code> 가 끝난 것으로 간주하지 않기 때문이다.</p><p>그러면 <code>JobInstance</code> 는 <strong>어제의 실패한 <code>JobExecution</code> 과 오늘 성공한 <code>JobExecution</code> 두 개</strong>를 갖게 된다. 즉, <strong><code>JobExecution</code>을 여러 개 가질 수 있다.</strong></p><h3 id=jobexecution>JobExecution</h3><p><code>JobExecution</code> 은 <code>JobInstance</code>에 대한 한 번의 실행을 나타내는 객체이다.</p><p>위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 <code>Job</code>이 실패해 내일 다시 동일한 <code>Job</code> 을 실행하면 오늘, 내일의 실행 모두 같은 <code>JobInstance</code> 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 <code>JobExecution</code> 을 생성한다.</p><p><code>JobExecution</code> 인터페이스를 보면 <code>Job</code> 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. <code>JobExecution</code> 은 <code>JobInstance</code>, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.</p><p>다음은 <code>JobExecution</code> 내부의 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.JobExecution</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobExecution</span> <span style=color:#66d9ef>extends</span> Entity {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JobParameters jobParameters;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> JobInstance jobInstance;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Collection<span style=color:#f92672>&lt;</span>StepExecution<span style=color:#f92672>&gt;</span> stepExecutions <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>synchronizedSet</span>(<span style=color:#66d9ef>new</span> LinkedHashSet<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> BatchStatus status <span style=color:#f92672>=</span> BatchStatus.<span style=color:#a6e22e>STARTING</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date startTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date createTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date(System.<span style=color:#a6e22e>currentTimeMillis</span>());
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date endTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date lastUpdated <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExitStatus exitStatus <span style=color:#f92672>=</span> ExitStatus.<span style=color:#a6e22e>UNKNOWN</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExecutionContext executionContext <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionContext();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> List<span style=color:#f92672>&lt;</span>Throwable<span style=color:#f92672>&gt;</span> failureExceptions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String jobConfigurationName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>jobParameters</code> : <code>Job</code> 실행에 필요한 매개변수 데이터.</li><li><code>jobInstance</code> : <code>Job</code> 실행의 단위가 되는 객체.</li><li><code>stepExecutions</code> : <code>StepExecution</code>을 여러 개 가질 수 있는 Collection 타입.</li><li><code>status</code> : <code>Job</code>의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>)</li><li><code>startTime</code> : <code>Job</code> 이 실행된 시간. <code>null</code> 이면 시작하지 않았다는 뜻.</li><li><code>createTime</code> : <code>JobExecution</code> 이 생성된 시간.</li><li><code>endTime</code> : <code>JobExecution</code>이 끝난 시간.</li><li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li><li><code>exitStatus</code> : <code>Job</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>)</li><li><code>executionContext</code> : <code>Job</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li><li><code>failureExceptions</code> : <code>Job</code> <strong>실행 중 발생한 예외</strong>를 <code>List</code> 에 넣어둔다.</li><li><code>jobConfigurationName</code> : <code>Job</code> 설정 이름.</li></ul><h3 id=jobparameters>JobParameters</h3><p><code>JobParameters</code> 는 <strong><code>Job</code> 이 실행될 때 필요한 파라미터</strong>들을 <code>Map</code> 타입으로 저장하는 객체이다.</p><p><code>JobParameters</code> 는 <strong><code>JobInstance</code> 를 구분하는 기준</strong>이 되기도 한다. 예를 들어 <code>Job</code> 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 <code>JobInstance</code> 를 생성한다.</p><p>즉, <code>JobInstance</code>와 <code>JobParameters</code> 는 1:1 관계이다. 파라미터의 타입으로는 <code>String</code> , <code>Long</code> , <code>Date</code> , <code>Double</code> 을 사용할 수 있다.</p><h2 id=step>Step</h2><p><code>Step</code>은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. <strong><code>Job</code> 을 처리하는 실질적인 단위</strong>로 쓰인다.</p><p><strong>모든 <code>Job</code> 에는 1개 이상의 <code>Step</code>이 있어야 한다.</strong></p><h3 id=stepexecution>StepExecution</h3><p><code>Job</code> 에 <code>JobExecution</code> 이라는 <code>Job</code> 실행 정보가 있다면, <code>Step</code>에는 <code>StepExecution</code> 이라는 <code>Step</code> 실행 정보를 담는 객체가 있다. 각각의 <code>Step</code> 이 실행될 때마다 <code>StepExecution</code> 이 생성된다.</p><p>다음은 <code>StepExecution</code> 클래스이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StepExecution</span> <span style=color:#66d9ef>extends</span> Entity {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JobExecution jobExecution;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String stepName;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> BatchStatus status <span style=color:#f92672>=</span> BatchStatus.<span style=color:#a6e22e>STARTING</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> readCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> writeCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> commitCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> rollbackCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> readSkipCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> processSkipCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> writeSkipCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date startTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date createTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date(System.<span style=color:#a6e22e>currentTimeMillis</span>());
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date endTime <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Date lastUpdated <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExecutionContext executionContext <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionContext();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ExitStatus exitStatus <span style=color:#f92672>=</span> ExitStatus.<span style=color:#a6e22e>EXECUTING</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> terminateOnly;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> filterCount;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>volatile</span> List<span style=color:#f92672>&lt;</span>Throwable<span style=color:#f92672>&gt;</span> failureExceptions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>jobExecution</code> : 현재의 <code>JobExecution</code> 정보.</li><li><code>stepName</code> : <code>Step</code>의 이름.</li><li><code>status</code> : <code>Step</code> 의 <strong>실행 상태</strong>. (<code>COMPLETED</code>, <code>STARTING</code>, <code>STARTED</code>, <code>STOPPING</code>, <code>STOPPED</code>, <code>FAILED</code>, <code>ABANDONED</code>, <code>UNKNOWN</code> 등이 있다. default는 <code>STARTING</code>.)</li><li><code>readCount</code> : 성공적으로 <strong>읽은 레코드 수</strong>.</li><li><code>writeCount</code> : 성공적으로 <strong>쓴 레코드 수</strong>.</li><li><code>commitCount</code> : <code>Step</code>의 실행에 대해 <strong>커밋된 트랜잭션 수</strong>.</li><li><code>rollbackCount</code> : <code>Step</code>의 실행에 대해 <strong>롤백된 트랜잭션 수</strong>.</li><li><code>readSkipCount</code> : 읽기에 실패해 건너뛴 레코드 수.</li><li><code>processSkipCount</code> : 프로세스가 실패해 건너뛴 레코드 수.</li><li><code>writeSkipCount</code> : 쓰기에 실패해 건너뛴 레코드 수.</li><li><code>startTime</code> : <code>Step</code>이 실행된 시간. <code>null</code>이면 시작하지 않았다는 뜻.</li><li><code>endTime</code> : <code>Step</code>의 <strong>실행 성공 여부와 관련 없이</strong> <code>Step</code>이 끝난 시간.</li><li><code>lastUpdated</code> : 마지막으로 수정된 시간.</li><li><code>executionContext</code> : <code>Step</code> 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다.</li><li><code>exitStatus</code> : <code>Step</code> <strong>실행 결과에 대한 상태</strong>. (<code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code> 등이 있다. default는 <code>UNKNOWN</code>.)</li><li><code>terminateOnly</code> : <code>Job</code> 실행 중지 여부.</li><li><code>filterCount</code> : 실행에서 필터링된 레코드 수.</li><li><code>failureExceptions</code> : <code>Step</code> 실행 중 발생한 예외를 <code>List</code> 타입으로 저장한다.</li></ul><h2 id=jobrepository>JobRepository</h2><p><code>JobRepository</code> 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 <code>Job</code>이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 <strong>배치 처리에 대한 메타데이터를 저장</strong>한다.</p><p>예를 들어 <code>Job</code> 하나가 실행되면 <code>JobRepository</code> 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 <code>JobExecution</code> 을 생성한다.</p><p><code>JobRepository</code> 는 <code>Step</code> 의 실행 정보를 담고 있는 <code>StepExecution</code> 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.</p><h2 id=joblauncher>JobLauncher</h2><p><code>JobLauncher</code> 는 <code>Job</code> , <code>JobParameters</code> 와 함께 <strong>배치를 실행하는 인터페이스</strong>이다. 인터페이스는 <code>run()</code> 하나이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.core.launch.JobLauncher</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>JobLauncher</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobExecution <span style=color:#a6e22e>run</span>(Job job, JobParameters jobParameters) <span style=color:#66d9ef>throws</span> ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>매개변수로 <code>Job</code>과 <code>JobParameters</code>를 받아 <code>JobExecution</code>을 반환한다. <strong>매개변수가 이전과 동일하면서 이전에 <code>JobExecution</code>이 중단된 적 있다면 동일한 <code>JobExecution</code>을 반환</strong>한다.</p><h2 id=itemreader>ItemReader</h2><p><code>ItemReader</code>는 <code>Step</code>의 대상이 되는 <strong>배치 데이터를 읽어오는 인터페이스</strong>이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemReader</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemReader</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	T <span style=color:#a6e22e>read</span>() <span style=color:#66d9ef>throws</span> Exception, UnexpectedException, ParseException, NonTransientResourceException;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ItemReader</code> 에서 <code>read()</code> 메서드의 반환 타입을 제네릭 <code>&lt;T></code> 으로 구성했기 때문에 직접 타입을 지정할 수 있다.</p><p>위에서 설명한 <em>읽기-처리-쓰기</em>에서 <strong>읽기를 담당</strong>한다고 볼 수 있겠다!</p><h2 id=itemprocessor>ItemProcessor</h2><p><code>ItemProcessor</code> 는 <code>ItemReader</code> 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.</p><p><em>읽기-처리-쓰기</em> 에서 <strong>처리를 담당</strong>한다고 볼 수 있겠다.</p><p>굳이 <code>ItemWriter</code>가 아니라 <code>ItemProcessor</code>라는 인터페이스를 분리한 이유는 두 가지다.</p><ol><li>비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다.</li><li>Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 <code>&lt;I, O></code>에 들어가게 되니 더 직관적이다.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemProcesor</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemProcessor</span><span style=color:#f92672>&lt;</span>I, O<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	O <span style=color:#a6e22e>process</span>(I item) <span style=color:#66d9ef>throws</span> Exception;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=itemwriter>ItemWriter</h2><p><code>ItemWriter</code> 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.</p><p>읽기-처리-쓰기에서 마지막 단계인 <strong>쓰기를 담당</strong>한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// org.springframework.batch.item.ItemWriter</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ItemWriter</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span>(List<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> items) <span style=color:#66d9ef>throws</span> Exception;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ItemWriter</code>은 <code>ItemReader</code>와 비슷한 방식으로 구현하면 된다.</p><p><code>write()</code> 메서드는 <code>List</code> 자료구조를 이용해 <strong>지정한 타입의 리스트</strong>를 매개변수를 받는다. 리스트의 데이터 수는 설정한 <strong>청크 (chunk) 단위</strong>로 불러온다.</p><p><code>write()</code> 메서드는 <code>void</code> 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.</p><h1 id=ref>REF</h1><ul><li><p><a href=http://www.yes24.com/Product/Goods/64584833>&lt;처음 배우는 스프링 부트 2> - 김영재 저</a></p></li><li><p><a href=https://github.com/spring-projects/spring-batch>GitHub - spring-batch</a></p></li><li><p><a href=https://spring.io/projects/spring-batch>Spring Doc - Spring Batch</a></p></li></ul></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><h1 class=about__title>litsynp.log</h1></div><ul class=aside__social-links><li><a href=https://www.github.com/litsynp rel=me aria-label=GitHub title=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a>&nbsp;</li><li><a href=https://www.linkedin.com/in/litsynp rel=me aria-label=LinkedIn title=LinkedIn><i class="fa-brands fa-linkedin" aria-hidden=true></i></a>&nbsp;</li><li><a href=https://docs.litsynp.com rel=me aria-label=GitBook title=GitBook><i class="fa fa-book" aria-hidden=true></i></a>&nbsp;</li><li><a href=mailto:nocte55is@gmail.com rel=me aria-label=Email title=Email><i class="fa-solid fa-envelope" aria-hidden=true></i></a>&nbsp;</li></ul><section><div>Latest Posts:</div><li><a href=https://blog.litsynp.com/posts/2024/07/28/weird-chars-on-macos/>맥북에서 한글 입력 시 알 수 없는 문자가 같이 입력되는 버그</a></li><li><a href=https://blog.litsynp.com/posts/2023/10/10/flip-flops-and-latches/>Flip-Flops and Latches</a></li><li><a href=https://blog.litsynp.com/posts/2023/10/08/hugo-from-scratch/>Hugo 블로그 만들기</a></li></section></div><hr><div class=aside__content><p>2022-06-04</p></div></section><section class=page__comments><script src=https://utteranc.es/client.js repo=litsynp/litsynp.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></section><footer class=page__footer><p><br><span class=active>$ echo $LANG<br><b>English</b></span><br></p><br><br><p class=copyright>© <a href=https://github.com/litsynp>litsynp</a>.</p><p class=advertisement>Powered by <a href=https://gohugo.io/>hugo</a> and <a href=https://github.com/joeroe/risotto>risotto</a>.</p></footer></div></body></html>