<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">
    <title>2장 리팩터링 원칙 :: litsynp.log</title>

    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/github.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/gruvbox-dark-hard.css" media="screen and (prefers-color-scheme: dark)">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

    <!-- Highlight.js Copy -->
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css">

    <script>
      hljs.highlightAll();
      hljs.addPlugin(new CopyButtonPlugin());
    </script>

  </head>

  <body>
    <div class="wrapper-without-footer">
      <header class="header">
        <center>
          <div class="header-inner-container">
            <a href="/">litsynp.log</a>
            <hr>
            <nav>
              <a href="/">About</a>
              <a href="/posts">Posts</a>
              <a href="/series">Series</a>
            </nav>
          </div>
        </center>
      </header>

      <main>
        
  <h1>2장 리팩터링 원칙</h1>
  <p class="post-description">리팩터링 전반에 적용되는 원칙 몇 가지를 이야기해보자.</p>
  <time class="postlist-date" datetime="02/03/2023">02/03/2023</time>
  <hr>
  <h3>리팩터링: 정의</h3>
<h4>명사 정의, 동사 정의</h4>
<p>리팩터링은 엔지니어들 사이에서 다소 두리뭉실한 의미로 사용되지만, 저자는 이 용어를 좀 더 구체적인 의미로 사용해야 더 유용하다고 믿는다.</p>
<blockquote>
<p>리팩터링(refactoring): [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법</p>
</blockquote>
<blockquote>
<p>리팩터링하다(refactor): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.</p>
</blockquote>
<p>이 두 버전의 용어를 한 문장에 담으면: '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 것 같다'처럼 표현할 수 있다.</p>
<h4>그렇다면 어디까지가 리팩터링인가</h4>
<p>코드를 정리하는 작업을 모조리 리팩터링이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.</p>
<blockquote>
<p>리팩터링은 결국 동작을 보존하는 <strong>작은 단계들을 거쳐 코드를 수정</strong>하고, 이러한 단계들을 <strong>순차적으로 연결하여 큰 변화를 만들어내는 일</strong>이다.</p>
</blockquote>
<ul>
<li>개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다.</li>
<li>따라서 리팩터링하는 동안에는 <strong>코드가 항상 정상 작동하기 때문에</strong> 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.</li>
</ul>
<blockquote>
<p>누군가 &quot;리팩터링 하다가 코드가 깨져서 며칠이나 고생했다&quot;라고 한다면, 십중팔구 리팩터링한 것이 아니다.</p>
</blockquote>
<h4>재구성(Restructuring)과 리팩터링(Refactoring)</h4>
<p>저자는 다음과 같이 정리한다.</p>
<ul>
<li>재구성(restructuring): 코드베이스를 정리하거나 구조를 바꾸는 모든 작업.</li>
<li>리팩터링은 재구성의 특수한 한 형태이다.</li>
</ul>
<h3>두 개의 모자: '기능 추가', '리팩터링'</h3>
<ul>
<li>'기능 추가' 모자를 쓰면 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.</li>
<li>'리팩터링' 모자를 쓰면 기능 추가는 절대 하지 않고 코드 재구성에만 전념한다. 테스트도 새로 만들지 않고, 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.</li>
</ul>
<p>새 기능을 추가하다보면 코드 구조를 바꿔야 작업하기 쉽겠다는 생각이 들 때가 있는데, 그러면 잠시 모자를 바꿔 쓰고 리팩터링한다. 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어 간다.</p>
<p>항상 내가 쓰고 있는 모자가 무엇인지, 그리고 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.</p>
<h3>리팩터링: 이유</h3>
<p>각 문장을 보면 당연한 내용이지만 책에 담긴 설명이 좋다. 아무래도 내가 리팩터링에 대한 도움이 절실히 필요한 상태고 실제로 잘못된 리팩터링을 통해 문제를 겪었기 때문에 더욱 와닿는 것 같다. 자세한 내용은 길어지니 책을 참고하자.</p>
<ul>
<li>리팩터링하면 설계가 좋아진다.</li>
<li>리팩터링하면 소프트웨어를 이해하기 쉬워진다.
<ul>
<li>코드 리뷰에도 도움이 된다.
<ul>
<li>페어 프로그래밍</li>
</ul>
</li>
</ul>
</li>
<li>리팩터링하면 버그를 쉽게 찾을 수 있다.</li>
<li>리팩터링하면 프로그래밍 속도를 높일 수 있다.</li>
</ul>
<blockquote>
<p>리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다. 그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.</p>
</blockquote>
<h3>리팩터링: 종류</h3>
<p>기회가 될 때만 진행:</p>
<ul>
<li>(기능 개발, 버그 픽스 등의) 준비를 위한 리팩터링</li>
<li>이해를 위한 리팩터링</li>
<li>쓰레기 줍기 리팩터링</li>
</ul>
<p>저자는 리팩터링 일정을 따로 잡지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 자연스럽게 함께 한다.</p>
<blockquote>
<p>보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.</p>
</blockquote>
<blockquote>
<p>무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.<br>
- 켄트 벡 (출처: <a href="https://twitter.com/kentbeck/status/250733358307500032">Twitter</a>)</p>
</blockquote>
<h3>리팩터링: 하지 말아야 할 때</h3>
<ul>
<li>지저분한 코드를 발견해도 굳이 수정할 필요가 없는 경우
<ul>
<li>e.g., 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 둔다.</li>
<li><strong>내부 동작을 이해해야 할 시점에 리팩터링해야</strong> 효과를 제대로 볼 수 있다.</li>
</ul>
</li>
<li>리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.</li>
</ul>
<h3>리팩터링: 고려할 문제</h3>
<h4>새 기능 개발 속도 저하</h4>
<p>리팩터링의 본질은 클린 코드, 바람직한 엔지니어링 습관에 있는 게 아니다. <strong>오로지 경제적인 이유로</strong> 하는 것이다. 개발 기간을 단축하고, 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.</p>
<h4>코드 소유권</h4>
<p>코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.</p>
<h4>브랜치</h4>
<p>지속적 통합(Continuous Integration, CI), 또는 트렁크 기반 개발(Trunk-Based Development, TBD) - 기능별 브랜치의 통합 주기를 매우 짧게 유지해야 한다.</p>
<ul>
<li>CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터에 통합한다.</li>
<li>이렇게 하려면 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능 토클(feature toggle) 또는 기능 플래그(feature flag)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.</li>
</ul>
<h4>테스팅</h4>
<ul>
<li>리팩터링하면 동작이 깨지지 않아야 한다.</li>
<li>리팩터링은 단계별 변경 폭이 작아서 오류의 원인이 될만한 코드 범위가 넓지 않다.</li>
<li>핵심은 <strong>오류를 재빨리 잡는 데</strong> 있다. 그렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다. 달리 말해, 리팩터링하기 위해서는 (대부분) <strong>자가 테스트 코드(self-testing code)</strong> 를 마련해야 한다.</li>
</ul>
<h4>레거시 코드</h4>
<ul>
<li>레거시 코드는 대체로 복잡하고 테스트가 제대로 갖춰지지 않은 것이 많다. 무엇보다 다른 사람이 작성한 것이다.</li>
<li>레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다.</li>
<li>문제에 대한 정답은 당연히 테스트 보강이다.</li>
<li>쉽지는 않다. <a href="http://www.yes24.com/Product/Goods/64586851"><em>레거시 코드 활용 전략</em></a>*(에이콘, 2018)*에 나온 지침을 따르는 것이다. 주요 내용은 '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다'는 것이다.</li>
<li>(저자에 따르면) 단번에 리팩터링하는 것보다 서로 연관된 부분끼리 나눠서 하나씩 공략하면 좋다.</li>
</ul>
<h4>데이터베이스</h4>
<p>이 책의 초판에서 데이터베이스는 리팩터링하기 어려운 영역이라고 말했지만, 출간 후 일 년도 지나지 않아서 틀린 말이 되었다.</p>
<ul>
<li>진화형 데이터베이스 설계(evolutionary database design)</li>
<li>데이터베이스 리팩터링 기법</li>
</ul>
<p>이 널리 사용되고 있다. 이 기법의 핵심은:</p>
<ul>
<li>커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고,</li>
<li>접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.</li>
</ul>
<h3>리팩터링, 아키텍처, 애그니(YAGNI)</h3>
<p>코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다.</p>
<p>그런데 <strong>우리는 실제로 소프트웨어를 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야</strong> 원하는 바를 알게 되는 경우가 허다하다.</p>
<ul>
<li>향후 변경에 대처할 수 있는 유연성 메커니즘(flexibility mechanism)을 소프트웨어에 심어두는 방법이 있다.
<ul>
<li>함수를 정의하다가 범용적으로 사용할 수 있겠다는 판단이 들면, 예상 시나리오에 대처할 수 있는 매개변수들을 추가한다. 이런 매개변수가 바로 유연성 메커니즘이다.</li>
<li>그러나 이런 매개변수는 당장 필요 없거나, 함수를 복잡하게 만들고, 유연성 메커니즘이 잘못 구현될 때도 있다.</li>
</ul>
</li>
<li>리팩터링을 활용하면 다르게 접근할 수 있다.
<ul>
<li>앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추축하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.</li>
<li>진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.</li>
<li>복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.</li>
<li>호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다. 매개변수를 추가할 시점이 오면 간단한 리팩터링 기법인 <strong>함수 매개변수화하기</strong>로 해결한다.</li>
<li>예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많다. 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.</li>
<li>이렇게 설계하는 방식을 <strong>간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(애그니, &quot;you aren't going to need it&quot;의 줄임말)</strong> 라고 한다.</li>
</ul>
</li>
</ul>
<h3>리팩터링과 소프트웨어 개발 프로세스</h3>
<ul>
<li>리팩터링이 퍼지기 시작한 것도 익스트림 프로그래밍(XP)에 도입됐기 때문이었다.</li>
<li>XP의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다.</li>
<li>자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(Test-Driven Development, TDD)이라 한다.</li>
<li>YAGNI를 위한 세 가지 기법의 상승효과
<ul>
<li>자가 테스트 코드</li>
<li>지속적 통합</li>
<li>리팩터링</li>
</ul>
</li>
</ul>
<h3>리팩터링과 성능</h3>
<p>리팩터링하면 프로그램 성능이 느려질까봐 걱정하지만, 실제로 소프트웨어를 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우가 많다.</p>
<p>리팩터링하면 소프트웨어가 느려질 수 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.</p>
<p>빠른 소프트웨어를 작성하는 세 가지 방법이 있다.</p>
<ul>
<li>하나는 시간 예산 분배(time budgeting) 방식으로, 하드 리얼타임 시스템에서 많이 사용한다.
<ul>
<li>이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다.</li>
</ul>
</li>
<li>하나는 끊임없이 관심을 기울이는 것이다.</li>
<li>마지막은 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.</li>
</ul>


      </main>
    </div>

    <footer>
      <center>
        <div class="footer-inner-container">
          <hr>
          <p>© litsynp.log</p>
        </div>
      </center>
    </footer>
  </body>
</html>