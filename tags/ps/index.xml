<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ps on litsynp.log</title><link>https://blog.litsynp.com/tags/ps/</link><description>Recent content in ps on litsynp.log</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© [litsynp](https://github.com/litsynp).</copyright><lastBuildDate>Fri, 06 May 2022 23:36:45 +0900</lastBuildDate><atom:link href="https://blog.litsynp.com/tags/ps/index.xml" rel="self" type="application/rss+xml"/><item><title>Java - List&lt;Integer>에서 remove()를 이용한 원소 삭제 간 주의점</title><link>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</link><pubDate>Fri, 06 May 2022 23:36:45 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</guid><description>Java - List&amp;lt;Integer&amp;gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.
import java.util.*; // ... 중략 List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.
boolean remove(Object o); &amp;ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)</description></item><item><title>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우</title><link>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link><pubDate>Thu, 28 Apr 2022 15:49:15 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid><description>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.
그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.
static을 이용해 전역으로 설정하고 있었다면,
참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.
추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.</description></item></channel></rss>