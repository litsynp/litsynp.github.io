<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>problem-solved on litsynp.log</title><link>https://blog.litsynp.com/categories/problem-solved/</link><description>Recent content in problem-solved on litsynp.log</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© [litsynp](https://github.com/litsynp).</copyright><lastBuildDate>Fri, 06 May 2022 23:36:45 +0900</lastBuildDate><atom:link href="https://blog.litsynp.com/categories/problem-solved/index.xml" rel="self" type="application/rss+xml"/><item><title>Java - List&lt;Integer>에서 remove()를 이용한 원소 삭제 간 주의점</title><link>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</link><pubDate>Fri, 06 May 2022 23:36:45 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/</guid><description>Java - List&amp;lt;Integer&amp;gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.
import java.util.*; // ... 중략 List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.
boolean remove(Object o); &amp;ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)</description></item><item><title>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우</title><link>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link><pubDate>Thu, 28 Apr 2022 15:49:15 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid><description>프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.
그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.
static을 이용해 전역으로 설정하고 있었다면,
참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.
추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.</description></item><item><title>Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7</title><link>https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/</link><pubDate>Fri, 08 Apr 2022 16:59:02 +0900</pubDate><guid>https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/</guid><description>Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.
Kotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.
Gradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.
하지만 index.html 파일이 생성되지 않았다.
예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.
Spring Boot | REST Docs 적용하기 ( + build failed 해결.</description></item><item><title>Spring Boot에서 Swagger UI 접속이 안되는 경우</title><link>https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</link><pubDate>Sun, 05 Sep 2021 01:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/</guid><description>문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.
원인 아마도 dependencies를 잘못 설정했을 확률이 높다.
해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,
implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger-ui&amp;#39;, version: &amp;#39;3.0.0&amp;#39; implementation group: &amp;#39;io.springfox&amp;#39;, name: &amp;#39;springfox-swagger2&amp;#39;, version: &amp;#39;3.0.0&amp;#39; 다음과 같이 바꾼다.
implementation &amp;#34;io.springfox:springfox-boot-starter:3.0.0&amp;#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍</description></item><item><title>Getting Ambiguous @ExceptionHandler method mapped for XXXException</title><link>https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-@exceptionhandler-method-mapped-for-xxxexception/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0900</pubDate><guid>https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-@exceptionhandler-method-mapped-for-xxxexception/</guid><description>문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,
Getting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.
원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.
해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)
REF Stack Overflow</description></item></channel></rss>