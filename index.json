[{"content":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.\n이런 식으로 실전에서 맞아야 할 몇 문제를 더 틀렸을 수도 있었을 것 같다\u0026hellip;\n주의 해야겠다!\n","permalink":"https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.","title":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우"},{"content":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\n Gradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용  첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.. ) 글을 읽어보고 src/docs/asciidoc/ 경로에 index.adoc 파일을 만들어본다.\n두 번째 이슈 - Gradle 7과 asciidoc의 문제 Spring Initializr을 이용하여 스프링 부트 프로젝트를 만든 상태였고, 자동으로 org.asciidoctor.convert 플러그인이 설정된 상황이었다.\n그런데 ./gradlew asciidoctor을 실행했을 때 나오는 오류가 다음과 같았다.\nIn plugin \u0026#39;org.asciidoctor.convert\u0026#39; type \u0026#39;org.asciidoctor.gradle.AsciidoctorTask\u0026#39; method \u0026#39;asGemPath()\u0026#39; should not be annotated with: @Optional, @InputDirectory. 구글링을 통해 찾아보니, Gradle 7과는 해당 플러그인이 현재 호환이 되지 않는 것으로 판단되었다.\n선택 가능한 방법은 다음과 같다.\n  Gradle의 버전을 6 이하의 버전으로 낮춘다.\n  오류를 잘 수정해본다.\n  Gradle 7을 현재 사용 중이기 때문에 1번과 같이 그냥 버전을 낮추는 건 찜찜했다. 따라서 오류를 잘 수정해보기로 했다.\n찾아봐도 어떻게 고쳐야되는지 예제가 잘 안나오지만, 결국 GitHub에서 되는 예제를 찾았다!\n다음과 같이 진행하면 된다.\nplugins {  // ...  id(\u0026#34;org.asciidoctor.jvm.convert\u0026#34;) version \u0026#34;3.3.2\u0026#34; }  val asciidoctorExtensions: Configuration by configurations.creating  dependencies {  // ...  asciidoctorExtensions(\u0026#34;org.springframework.restdocs:spring-restdocs-asciidoctor\u0026#34;) }  // ...  tasks.clean {  delete(\u0026#34;src/main/resources/static/docs\u0026#34;) }  tasks.test {  systemProperty(\u0026#34;org.springframework.restdocs.outputDir\u0026#34;, snippetsDir)  outputs.dir(snippetsDir) }   tasks.build {  dependsOn(\u0026#34;copyDocument\u0026#34;) }  tasks.asciidoctor {  dependsOn(tasks.test)   attributes(  mapOf(\u0026#34;snippets\u0026#34; to snippetsDir)  )  inputs.dir(snippetsDir)   doFirst {  delete(\u0026#34;src/main/resources/static/docs\u0026#34;)  } }  tasks.register(\u0026#34;copyDocument\u0026#34;, Copy::class) {  dependsOn(tasks.asciidoctor)  from(tasks.asciidoctor.get().outputDir)  into(file(\u0026#34;src/main/resources/static/docs\u0026#34;)) }  tasks.bootJar {  dependsOn(tasks.asciidoctor)   from(tasks.asciidoctor.get().outputDir) {  into(\u0026#34;BOOT-INF/classes/static/docs\u0026#34;)  } } REF Spring REST Docs in General Spring REST Docs + Kotlin 예제\n‘Gradle Kotlin DSL’ 이야기\nTroubleshooting 첫 번째 이슈\n  https://blog.naver.com/PostView.naver?blogId=qjawnswkd\u0026amp;logNo=222409742108\u0026amp;parentCategoryNo=\u0026amp;categoryNo=41\u0026amp;viewDate=\u0026amp;isShowPopularPosts=false\u0026amp;from=postView\n  Spring Boot | REST Docs 적용하기 ( + build failed 해결.. )\n  두 번째 이슈\n  [Spring] Spring rest docs 적용기(gradle 7.0.2)\n  결론으로, 다음 GitHub에 올라온 이슈에서의 build.gradle.kts를 따라하여 해결\n Configure a Gradle 7 compatible version of Asciidoctor\u0026rsquo;s Gradle plugin in projects using REST Docs #676    ","permalink":"https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/","summary":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\n Gradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용  첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.","title":"Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7"},{"content":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC)  stop-the-world  GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다.   Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다. 이 과정에서 stop-the-world가 발생한다. 이후 Mark 되어있지 않은 객체들을 힙에서 제거하는 과정이 Sweep이다. Reachability  Java의 GC는 가비지 객체를 판별하기 위해 reachability 라는 개념을 사용한다. reachable은 Stack에서 Heap 영역의 객체에 대해 참조 할 수 있는지를 뜻한다. 어떤 객체에 유효한 참조가 있으면 reachable, 없으면 unreachable로 구별한다. unreachable 객체를 가비지로 간주한다.   JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉜다. Young 영역에서 발생한 GC를 Minor GC, 나머지 두 영역에서 발생한 GC를 Major GC(Full GC)라고 한다.  Young (Generation) 영역: 새롭게 생성한 객체가 위치한다. 대부분의 객체가 금방 unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다. Old (Generation) 영역: Young 영역에서 reachable 상태를 유지해 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. Perm 영역: Method Area라고도 한다. 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역이다.    REF https://d2.naver.com/helloworld/1329\nhttps://velog.io/@litien/가비지-컬렉터GC\n","permalink":"https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/","summary":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC)  stop-the-world  GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다.   Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.","title":"[Java] Garbage Collector in JVM"},{"content":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config;  import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient;  @Configuration public class WebClientConfig {   @Bean  public WebClient.Builder getWebClientBuilder() {  return WebClient.builder();  } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.\nimport org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient;  @Service @RequiredArgsConstructor public class ExterrnalApiService {   private final WebClient.Builder webClientBuilder;   public ResponseEntity\u0026lt;?\u0026gt; get() {  return webClientBuilder.baseUrl(\u0026#34;https://randomuser.me\u0026#34;).build()  .get()  .uri(\u0026#34;/api\u0026#34;)  .retrieve()  .toEntity(Object.class) // Response DTO Type  .block();  }   public ResponseEntity\u0026lt;?\u0026gt; create() {  return webClientBuilder.baseUrl(\u0026#34;https://gorest.co.in\u0026#34;).build()  .post()  .uri(\u0026#34;/public/v2/users\u0026#34;)  .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer AAA.BBB.CCC\u0026#34;)  .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)  .bodyValue(new HashMap\u0026lt;String, Object\u0026gt;() {{  put(\u0026#34;email\u0026#34;, \u0026#34;abdasdfc@tesat.com\u0026#34;);  put(\u0026#34;name\u0026#34;, \u0026#34;abc\u0026#34;);  put(\u0026#34;gender\u0026#34;, \u0026#34;male\u0026#34;);  put(\u0026#34;status\u0026#34;, \u0026#34;active\u0026#34;);  }})  .retrieve()  .toEntity(Object.class)  .block();  } } * Used https://randomuser.me and https://gorest.co.in for external API testing.\nREF https://stackoverflow.com/questions/42365266/call-another-rest-api-from-my-server-in-spring-boot\nhttps://bravenamme.github.io/2021/01/07/web_client/\n","permalink":"https://blog.litsynp.com/posts/2022/02/11/spring-boot-external-api-call/","summary":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config;  import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient;  @Configuration public class WebClientConfig {   @Bean  public WebClient.Builder getWebClientBuilder() {  return WebClient.builder();  } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.","title":"[Spring Boot] External API Call"},{"content":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란  웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다.  DD는 웹 애플리케이션 실행 시 메모리에 로드된다.   web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다.  설정이란  web.xml은 크게 세 개의 설정을 한다.  DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리    DispatcherServlet   DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.\n  요청을 직접 처리하지 않고 적절한 객체에게 역할을 위임하여 클라이언트의 요청을 처리한다.\n  요청을 처리하기 위해서 크게 4가지 일이 진행되어야 한다.\n 클라이언트의 요청을 처리해줄 컨트롤러를 찾는다.  HandlerMapping이라는 객체가 요청을 처리할 컨트롤러를 검색하는 역할을 하는데, 클라이언트의 요청 경로를 이용해 컨트롤러를 검색 후, 검색된 객체를 DispatcherServlet에게 전달한다.   컨트롤러를 실행시킨다. 즉, 비즈니스 로직을 처리한다.  HandlerAdapter라는 객체가 컨트롤러를 실행시키는 역할을 하는데, @Controller 어노테이션을 이용하여 구현한 컨트롤러 뿐만 아니라, Controller 인터페이스를 구현한 컨트롤러, 특수 목적으로 사용되는 HttpRequestHandler 인터페이스를 구현한 클래스를 동일한 방식으로 실행할 수 있도록 한다. 실행된 Controller는 리턴할 데이터와 View를 HandlerAdapter에게 리턴한다. Handler Adapter는 데이터와 view를 ModelAndView 형태로 DispatcherServlet에게 리턴한다.   클라이언트에게 보여질 View를 찾는다.  ViewResolver 객체가 클라이언트에게 보여질 view를 찾는 역할을 한다.   응답 데이터와 View를 클라이언트에게 전달한다.  최종적으로 ViewResolver 객체가 리턴한 View 객체에 응답 데이터를 넣어 클라이언트에게 리턴한다.      ContextLoaderListener  웹 애플리케이션의 규모가 커진다면, 클라이언트의 요청 또한 다양해질 것이고, 이를 처리할, 즉 클라이언트의 요청을 처리하는 역할을 가진 DispatcherServlet도 늘어날 수 있다. 다른 성격을 가진 서블릿을 만들어야 할 수 있으니, 서블릿의 성격에 맞게 설정도 각각 적용시켜야 한다. 그러나 모든 서블릿이 공통으로 가져야 할 설정도 존재한다. 즉 Servlet Context 단위가 아닌, (Web) Application Context 단위의 설정이 필요한데, 이를 ContextLoaderListener 객체가 처리한다.  Filter  Filter란, 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 부분이다. e.g.) Spring Security Filter가 적용되어 있다면, 인가 및 인증 처리를 먼저 처리한 후 DispatcherServlet에게 요청을 전달할 것이다. e.g.) Encoding Filter가 적용되어 있다면 클라이언트의 요청 데이터를 인코딩하는 작업이 선 처리된 후 DispatcherServlet에게 필터링 된 데이터가 전달된다.  ","permalink":"https://blog.litsynp.com/posts/2022/01/21/tir-about-web.xml/","summary":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란  웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다.  DD는 웹 애플리케이션 실행 시 메모리에 로드된다.   web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다.  설정이란  web.xml은 크게 세 개의 설정을 한다.  DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리    DispatcherServlet   DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.","title":"[TIR] About web.xml"},{"content":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","permalink":"https://blog.litsynp.com/posts/2022/01/07/tir-redis-vs-kafka-vs-rabbitmq/","summary":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","title":"[TIR] Redis vs Kafka vs RabbitMQ"},{"content":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer):  non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True)   class Meta:  model = User  fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;)   def validate(self, attrs):  # ...  attrs.pop(\u0026#39;non_model_field\u0026#39;, None)  return super().validate(attrs) REF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/01/05/drf-serializer%EC%97%90-writable-non-model-field-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/","summary":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer):  non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True)   class Meta:  model = User  fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;)   def validate(self, attrs):  # ...  attrs.","title":"[DRF] Serializer에 writable non-model field 추가하기"},{"content":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍","title":"Spring Boot에서 Swagger UI 접속이 안되는 경우"},{"content":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-exceptionhandler-method-mapped-for-xxxexception/","summary":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  Stack Overflow","title":"Getting Ambiguous @ExceptionHandler method mapped for XXXException"},{"content":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs):  user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;))   # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인  if self.request.user.id == user_id:  return super(UserViewSet, self).destroy(request, *args, **kwargs)  else:  response = {  \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.\u0026#39;}  return Response(response, status=status.HTTP_403_FORBIDDEN) 아무튼 예시에 간략하게 설명을 덧붙이자면, 다음과 같다.\n 제시한 destroy 함수는 DRF의 ModelViewSet 를 상속한 클래스인 UserViewSet 내의 함수이다. destroy 함수를 override하여 새로운 기능을 제공하고자 한다. 로그인한 사용자의 ID와, URL에 있는 parameter (/users/:pk)의 pk 부분, 즉 조회하려는 사용자의 ID가 일치하는지를 확인한다.  일치하면 super() 를 이용하여 기존 destroy 함수를 호출해 해당 사용자를 DB에서 삭제한다. 일치하지 않으면 HTTP 상태 코드 403 Forbidden와 함께 response 메세지를 JSON으로 반환한다.    참고  위와 같이 작성하면 물론 로그인을 했는지부터 확인해야하기 때문에 permission_classes를 작성해야 한다. 또한, 위의 함수만 작성하면 DRF의 admin site에서는 DELETE 버튼이 비활성화되지 않는다. (물론 클릭하면 권한에 따라 reject 될 것이다)  REF Using super with a class method - (Stack Overflow)\n","permalink":"https://blog.litsynp.com/posts/2021/02/10/python-super-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B8%B0%EC%A1%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/","summary":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs):  user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;))   # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인  if self.request.user.id == user_id:  return super(UserViewSet, self).","title":"[Python] super() 이용해서 기존 메소드 이용하기"}]