[{"content":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다. JobBuilderFactory로 원하는 Job을 만들 수 있다. JobBuilderFactory의 get() 메서드로 JobBuilder를 생성하고 이를 응용하면 된다. org.springframework.batch.core.Configuration.annotation.JobBuilderFactory의 내부 코드이다. (길다 길어!)\n// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory public class JobBuilderFactory { private JobRepository jobRepository; public JobBuilderFactory(JobRepository jobRepository) { this.jobRepository = jobRepository; } public JobBuilder get(String name) { JobBuilder builder = new JobBuilder(name).repository(jobRepository); return builder; } } get() 메서드를 호출할 때마다 새로운 JobBuilder 인스턴스를 반환한다. 그리고 매번 생성할 때마다 JobBuilderFactory 를 생성할 때 주입받은 JobRepository 를 사용할 repository로 설정한다. 즉, 해당 JobBuilderFactory 에서 생성되는 모든 JobBuilder 가 동일한 리포지토리를 사용한다.\n아래는 JobBuilder 코드 일부이다.\n// org.springframework.batch.core.job.builder.JobBuilder // ... public SimpleJobBuilder start(Step step) { return new SimpleJobBuilder(this).start(step); } public JobFlowBuilder start(Flow flow) { return new JobFlowBuilder(this).start(flow); } public JobFlowBuilder flow(Step step) { return new JobFlowBuilder(this).start(step); } // ... 공통점은 모두 빌더를 반환한다는 점이다. JobBuilder은 Job을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 Job 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 Job 생성이 이루어지게 하는 의도로 파악된다.\n빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.\n메서드를 살펴보면 Job을 생성하기 위한 Step 또는 Flow를 파라미터로 받아 구체적인 빌더를 생성하고 있다. Job은 Step 또는 Flow 인스턴스의 컨테이너 역할을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.\n다음은 Job 생성 예제 코드이다.\n@Autowired private JobBuilderFactory jobBuilderFactory; @Bean public Job simpleJob() { return jobBuilderFactory.get(\u0026#34;simpleJob\u0026#34;) // \u0026#39;simpleJob\u0026#39; 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환 .start(simpleStep()) // `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder` .build(); // \u0026#39;simpleJob\u0026#39;이라는 이름을 가진 `Job`이 생성되어 반환 } JobInstance JobInstance 는 배치에서 Job 이 실행될 때 하나의 Job 실행 단위이다. 만약 하루에 한 번씩 배치의 Job 이 실행된다면, 어제와 오늘 실행한 각각의 Job을 JobInstance 라고 부를 수 있다.\n그렇다면 각각의 JobInstance 는 하나의 JobExecution (JobInstance에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.\n오늘 Job을 실행했는데 실패했다면 다음날 동일한 JobInstance 를 가지고 또 실행한다. Job 실행이 실패하면 JobInstance 가 끝난 것으로 간주하지 않기 때문이다.\n그러면 JobInstance 는 어제의 실패한 JobExecution 과 오늘 성공한 JobExecution 두 개를 갖게 된다. 즉, JobExecution을 여러 개 가질 수 있다.\nJobExecution JobExecution 은 JobInstance에 대한 한 번의 실행을 나타내는 객체이다.\n위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 Job이 실패해 내일 다시 동일한 Job 을 실행하면 오늘, 내일의 실행 모두 같은 JobInstance 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 JobExecution 을 생성한다.\nJobExecution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. JobExecution 은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.\n다음은 JobExecution 내부의 코드이다.\n// org.springframework.batch.core.JobExecution public class JobExecution extends Entity { private final JobParameters jobParameters; private JobInstance jobInstance; private volatile Collection\u0026lt;StepExecution\u0026gt; stepExecutions = Collections.synchronizedSet(new LinkedHashSet\u0026lt;\u0026gt;()); private volatile BatchStatus status = BatchStatus.STARTING; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN; private volatile ExecutionContext executionContext = new ExecutionContext(); private transient volatile List\u0026lt;Throwable\u0026gt; failureExceptions = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private final String jobConfigurationName; // ... } jobParameters : Job 실행에 필요한 매개변수 데이터. jobInstance : Job 실행의 단위가 되는 객체. stepExecutions : StepExecution을 여러 개 가질 수 있는 Collection 타입. status : Job의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING) startTime : Job 이 실행된 시간. null 이면 시작하지 않았다는 뜻. createTime : JobExecution 이 생성된 시간. endTime : JobExecution이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. exitStatus : Job 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN) executionContext : Job 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. failureExceptions : Job 실행 중 발생한 예외를 List 에 넣어둔다. jobConfigurationName : Job 설정 이름. JobParameters JobParameters 는 Job 이 실행될 때 필요한 파라미터들을 Map 타입으로 저장하는 객체이다.\nJobParameters 는 JobInstance 를 구분하는 기준이 되기도 한다. 예를 들어 Job 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 JobInstance 를 생성한다.\n즉, JobInstance와 JobParameters 는 1:1 관계이다. 파라미터의 타입으로는 String , Long , Date , Double 을 사용할 수 있다.\nStep Step은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. Job 을 처리하는 실질적인 단위로 쓰인다.\n모든 Job 에는 1개 이상의 Step이 있어야 한다.\nStepExecution Job 에 JobExecution 이라는 Job 실행 정보가 있다면, Step에는 StepExecution 이라는 Step 실행 정보를 담는 객체가 있다. 각각의 Step 이 실행될 때마다 StepExecution 이 생성된다.\n다음은 StepExecution 클래스이다.\npublic class StepExecution extends Entity { private final JobExecution jobExecution; private final String stepName; private volatile BatchStatus status = BatchStatus.STARTING; private volatile long readCount = 0; private volatile long writeCount = 0; private volatile long commitCount = 0; private volatile long rollbackCount = 0; private volatile long readSkipCount = 0; private volatile long processSkipCount = 0; private volatile long writeSkipCount = 0; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExecutionContext executionContext = new ExecutionContext(); private volatile ExitStatus exitStatus = ExitStatus.EXECUTING; private volatile boolean terminateOnly; private volatile long filterCount; private transient volatile List\u0026lt;Throwable\u0026gt; failureExceptions = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); // ... } jobExecution : 현재의 JobExecution 정보. stepName : Step의 이름. status : Step 의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING.) readCount : 성공적으로 읽은 레코드 수. writeCount : 성공적으로 쓴 레코드 수. commitCount : Step의 실행에 대해 커밋된 트랜잭션 수. rollbackCount : Step의 실행에 대해 롤백된 트랜잭션 수. readSkipCount : 읽기에 실패해 건너뛴 레코드 수. processSkipCount : 프로세스가 실패해 건너뛴 레코드 수. writeSkipCount : 쓰기에 실패해 건너뛴 레코드 수. startTime : Step이 실행된 시간. null이면 시작하지 않았다는 뜻. endTime : Step의 실행 성공 여부와 관련 없이 Step이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. executionContext : Step 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. exitStatus : Step 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN.) terminateOnly : Job 실행 중지 여부. filterCount : 실행에서 필터링된 레코드 수. failureExceptions : Step 실행 중 발생한 예외를 List 타입으로 저장한다. JobRepository JobRepository 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 Job이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장한다.\n예를 들어 Job 하나가 실행되면 JobRepository 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 JobExecution 을 생성한다.\nJobRepository 는 Step 의 실행 정보를 담고 있는 StepExecution 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.\nJobLauncher JobLauncher 는 Job , JobParameters 와 함께 배치를 실행하는 인터페이스이다. 인터페이스는 run() 하나이다.\n// org.springframework.batch.core.launch.JobLauncher public interface JobLauncher { public JobExecution run(Job job, JobParameters jobParameters) throws ... } 매개변수로 Job과 JobParameters를 받아 JobExecution을 반환한다. 매개변수가 이전과 동일하면서 이전에 JobExecution이 중단된 적 있다면 동일한 JobExecution을 반환한다.\nItemReader ItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.\n// org.springframework.batch.item.ItemReader public interface ItemReader\u0026lt;T\u0026gt; { T read() throws Exception, UnexpectedException, ParseException, NonTransientResourceException; } ItemReader 에서 read() 메서드의 반환 타입을 제네릭 \u0026lt;T\u0026gt; 으로 구성했기 때문에 직접 타입을 지정할 수 있다.\n위에서 설명한 읽기-처리-쓰기에서 읽기를 담당한다고 볼 수 있겠다!\nItemProcessor ItemProcessor 는 ItemReader 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.\n읽기-처리-쓰기 에서 처리를 담당한다고 볼 수 있겠다.\n굳이 ItemWriter가 아니라 ItemProcessor라는 인터페이스를 분리한 이유는 두 가지다.\n비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다. Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 \u0026lt;I, O\u0026gt;에 들어가게 되니 더 직관적이다. // org.springframework.batch.item.ItemProcesor public interface ItemProcessor\u0026lt;I, O\u0026gt; { O process(I item) throws Exception; } ItemWriter ItemWriter 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.\n읽기-처리-쓰기에서 마지막 단계인 쓰기를 담당한다.\n// org.springframework.batch.item.ItemWriter public interface ItemWriter\u0026lt;T\u0026gt; { void write(List\u0026lt;? extends T\u0026gt; items) throws Exception; } ItemWriter은 ItemReader와 비슷한 방식으로 구현하면 된다.\nwrite() 메서드는 List 자료구조를 이용해 지정한 타입의 리스트를 매개변수를 받는다. 리스트의 데이터 수는 설정한 청크 (chunk) 단위로 불러온다.\nwrite() 메서드는 void 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.\nREF \u0026lt;처음 배우는 스프링 부트 2\u0026gt; - 김영재 저\nGitHub - spring-batch\nSpring Doc - Spring Batch\n","permalink":"https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/","summary":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다.","title":"Spring Batch와 주요 클래스 정리"},{"content":"클린 코더 (The Clean Coder) 독서 - 1 음악 들으면서 About 저자: “밥 아저씨” 로버트 C. 마틴\n\u0026lt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신\u0026gt;의 저자이기도 함\n표지 사진은 M1 성운 (게 성운)이고, 푸른 색의 밝은 점은 펄서이다.\n책에서 다루는 내용 프로 소프트웨어 개발자의 마음가짐, 즉 소프트웨어 프로페셔널리즘에 관한 책이다.\n책임지는 일은 무서운 일이다. 기술자라면 시스템과 프로젝트에 대해 관리자는 알기 힘든 깊은 지식을 알아야 한다. 그 지식을 가지고 행동으로 옮겨야 할 책임이 있다.\n미리 읽어두기 프로 프로그래머란 책에서 내리는 “프로 프로그래머”의 정의란, 태도 attitude, 원칙 discipline, 행동 action 이 프로의 핵심이다.\n… 천공카드 (Punched Card)란? -\u0026gt; 720비트 천공카드\n정해진 위치에 구멍이 뚫려 있는지 아닌지로 2진법 데이터를 기록한 카드.\nOMR 카드의 시초라고 할 수 있다. 입력장치이자 기억장치가 된다.\n1991년에 출시한 게임인 스트리트 파이터 2를 천공카드로 프로그래밍하면 약 81,500 장의 천공카드를 사용해야 한다고 한다. (대단한데?)\n천공카드가 쓰이던 시절에는 주로 코볼과 포트란이 대표적으로 사용됐다고 한다. 언어 자체적으로 80 컬럼에 맞춰 코딩하도록 되어 있다고 한다. 그리고 코딩의 편의를 제공하도록 미리 인쇄된 코딩 용지 (Coding Form)이 있다고 한다. 아래와 같이 생겼다.\n로버트 마틴은 코딩 양식지 (Coding Form을 의미하는 듯 하다)에 인쇄 활자체 대문자 (e.g., ABC)로 쓰고, 연필을 2번 사용했다고 한다.\n코딩 양식지는 천공기사 (Keypunch Operator / 또는 좀 더 포괄적으로 Data Entry Clerk)에게 전달되어, 서류 접수함에서 코딩 양식지를 꺼내, 키 펀치 기계(Keypunch, 타자기와 비슷하지만 종이에 글자를 찍는 게 아니라 카드에 구멍을 뚫는다)로 “타이핑” 해서 넣었다고 한다. (펀치하다 는 동사를 써도 되지 않을까?)\n다음에 계속 책 더 읽으면 더 작성 예정!\n","permalink":"https://blog.litsynp.com/posts/2022/05/27/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94-the-clean-coder-%EB%8F%85%EC%84%9C-1/","summary":"클린 코더 (The Clean Coder) 독서 - 1 음악 들으면서 About 저자: “밥 아저씨” 로버트 C. 마틴\n\u0026lt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신\u0026gt;의 저자이기도 함\n표지 사진은 M1 성운 (게 성운)이고, 푸른 색의 밝은 점은 펄서이다.\n책에서 다루는 내용 프로 소프트웨어 개발자의 마음가짐, 즉 소프트웨어 프로페셔널리즘에 관한 책이다.\n책임지는 일은 무서운 일이다. 기술자라면 시스템과 프로젝트에 대해 관리자는 알기 힘든 깊은 지식을 알아야 한다. 그 지식을 가지고 행동으로 옮겨야 할 책임이 있다.","title":"클린 코더 (The Clean Coder) 독서 - 1"},{"content":"Java - List\u0026lt;Integer\u0026gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.\nimport java.util.*; // ... 중략 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.\nboolean remove(Object o); \u0026ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)\nE remove(int index); \u0026ndash; index번째 원소를 삭제 (index 번째 원소가 없다면 java.lang.IndexOutOfBoundsException 발생)\n당연한 거지만 List\u0026lt;Integer\u0026gt;를 만들었더라도, remove에서 int로 의도한 게 아니라면 remove 메소드 실행 간에 wrapping을 해줘야한다.\n또한 후자는 index 번째 원소가 없다면 Exception까지 발생하니 유의가 필요하다!\nSolution 상황과 용도에 맞게 인자를 넘겨주는 것이 바람직하다.\nREF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/","summary":"Java - List\u0026lt;Integer\u0026gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.\nimport java.util.*; // ... 중략 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.\nboolean remove(Object o); \u0026ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)","title":"Java - List\u003cInteger\u003e에서 remove()를 이용한 원소 삭제 간 주의점"},{"content":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.\n이런 식으로 실전에서 맞아야 할 몇 문제를 더 틀렸을 수도 있었을 것 같다\u0026hellip;\n주의 해야겠다!\n","permalink":"https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.","title":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우"},{"content":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\nGradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.. ) 글을 읽어보고 src/docs/asciidoc/ 경로에 index.adoc 파일을 만들어본다.\n두 번째 이슈 - Gradle 7과 asciidoc의 문제 Spring Initializr을 이용하여 스프링 부트 프로젝트를 만든 상태였고, 자동으로 org.asciidoctor.convert 플러그인이 설정된 상황이었다.\n그런데 ./gradlew asciidoctor을 실행했을 때 나오는 오류가 다음과 같았다.\nIn plugin \u0026#39;org.asciidoctor.convert\u0026#39; type \u0026#39;org.asciidoctor.gradle.AsciidoctorTask\u0026#39; method \u0026#39;asGemPath()\u0026#39; should not be annotated with: @Optional, @InputDirectory. 구글링을 통해 찾아보니, Gradle 7과는 해당 플러그인이 현재 호환이 되지 않는 것으로 판단되었다.\n선택 가능한 방법은 다음과 같다.\nGradle의 버전을 6 이하의 버전으로 낮춘다.\n오류를 잘 수정해본다.\nGradle 7을 현재 사용 중이기 때문에 1번과 같이 그냥 버전을 낮추는 건 찜찜했다. 따라서 오류를 잘 수정해보기로 했다.\n찾아봐도 어떻게 고쳐야되는지 예제가 잘 안나오지만, 결국 GitHub에서 되는 예제를 찾았다!\n다음과 같이 진행하면 된다.\nplugins { // ... id(\u0026#34;org.asciidoctor.jvm.convert\u0026#34;) version \u0026#34;3.3.2\u0026#34; } val asciidoctorExtensions: Configuration by configurations.creating dependencies { // ... asciidoctorExtensions(\u0026#34;org.springframework.restdocs:spring-restdocs-asciidoctor\u0026#34;) } // ... tasks.clean { delete(\u0026#34;src/main/resources/static/docs\u0026#34;) } tasks.test { systemProperty(\u0026#34;org.springframework.restdocs.outputDir\u0026#34;, snippetsDir) outputs.dir(snippetsDir) } tasks.build { dependsOn(\u0026#34;copyDocument\u0026#34;) } tasks.asciidoctor { dependsOn(tasks.test) attributes( mapOf(\u0026#34;snippets\u0026#34; to snippetsDir) ) inputs.dir(snippetsDir) doFirst { delete(\u0026#34;src/main/resources/static/docs\u0026#34;) } } tasks.register(\u0026#34;copyDocument\u0026#34;, Copy::class) { dependsOn(tasks.asciidoctor) from(tasks.asciidoctor.get().outputDir) into(file(\u0026#34;src/main/resources/static/docs\u0026#34;)) } tasks.bootJar { dependsOn(tasks.asciidoctor) from(tasks.asciidoctor.get().outputDir) { into(\u0026#34;BOOT-INF/classes/static/docs\u0026#34;) } } REF Spring REST Docs in General Spring REST Docs + Kotlin 예제\n‘Gradle Kotlin DSL’ 이야기\nTroubleshooting 첫 번째 이슈\nhttps://blog.naver.com/PostView.naver?blogId=qjawnswkd\u0026amp;logNo=222409742108\u0026amp;parentCategoryNo=\u0026amp;categoryNo=41\u0026amp;viewDate=\u0026amp;isShowPopularPosts=false\u0026amp;from=postView\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.. )\n두 번째 이슈\n[Spring] Spring rest docs 적용기(gradle 7.0.2)\n결론으로, 다음 GitHub에 올라온 이슈에서의 build.gradle.kts를 따라하여 해결\nConfigure a Gradle 7 compatible version of Asciidoctor\u0026rsquo;s Gradle plugin in projects using REST Docs #676 ","permalink":"https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/","summary":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\nGradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.","title":"Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7"},{"content":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다. 이 과정에서 stop-the-world가 발생한다. 이후 Mark 되어있지 않은 객체들을 힙에서 제거하는 과정이 Sweep이다. Reachability Java의 GC는 가비지 객체를 판별하기 위해 reachability 라는 개념을 사용한다. reachable은 Stack에서 Heap 영역의 객체에 대해 참조 할 수 있는지를 뜻한다. 어떤 객체에 유효한 참조가 있으면 reachable, 없으면 unreachable로 구별한다. unreachable 객체를 가비지로 간주한다. JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉜다. Young 영역에서 발생한 GC를 Minor GC, 나머지 두 영역에서 발생한 GC를 Major GC(Full GC)라고 한다. Young (Generation) 영역: 새롭게 생성한 객체가 위치한다. 대부분의 객체가 금방 unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다. Old (Generation) 영역: Young 영역에서 reachable 상태를 유지해 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. Perm 영역: Method Area라고도 한다. 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역이다. REF https://d2.naver.com/helloworld/1329\nhttps://velog.io/@litien/가비지-컬렉터GC\n","permalink":"https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/","summary":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.","title":"[Java] Garbage Collector in JVM"},{"content":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.\nimport org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service @RequiredArgsConstructor public class ExterrnalApiService { private final WebClient.Builder webClientBuilder; public ResponseEntity\u0026lt;?\u0026gt; get() { return webClientBuilder.baseUrl(\u0026#34;https://randomuser.me\u0026#34;).build() .get() .uri(\u0026#34;/api\u0026#34;) .retrieve() .toEntity(Object.class) // Response DTO Type .block(); } public ResponseEntity\u0026lt;?\u0026gt; create() { return webClientBuilder.baseUrl(\u0026#34;https://gorest.co.in\u0026#34;).build() .post() .uri(\u0026#34;/public/v2/users\u0026#34;) .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer AAA.BBB.CCC\u0026#34;) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .bodyValue(new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;email\u0026#34;, \u0026#34;abdasdfc@tesat.com\u0026#34;); put(\u0026#34;name\u0026#34;, \u0026#34;abc\u0026#34;); put(\u0026#34;gender\u0026#34;, \u0026#34;male\u0026#34;); put(\u0026#34;status\u0026#34;, \u0026#34;active\u0026#34;); }}) .retrieve() .toEntity(Object.class) .block(); } } * Used https://randomuser.me and https://gorest.co.in for external API testing.\nREF https://stackoverflow.com/questions/42365266/call-another-rest-api-from-my-server-in-spring-boot\nhttps://bravenamme.github.io/2021/01/07/web_client/\n","permalink":"https://blog.litsynp.com/posts/2022/02/11/spring-boot-external-api-call/","summary":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.","title":"[Spring Boot] External API Call"},{"content":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.\n요청을 직접 처리하지 않고 적절한 객체에게 역할을 위임하여 클라이언트의 요청을 처리한다.\n요청을 처리하기 위해서 크게 4가지 일이 진행되어야 한다.\n클라이언트의 요청을 처리해줄 컨트롤러를 찾는다. HandlerMapping이라는 객체가 요청을 처리할 컨트롤러를 검색하는 역할을 하는데, 클라이언트의 요청 경로를 이용해 컨트롤러를 검색 후, 검색된 객체를 DispatcherServlet에게 전달한다. 컨트롤러를 실행시킨다. 즉, 비즈니스 로직을 처리한다. HandlerAdapter라는 객체가 컨트롤러를 실행시키는 역할을 하는데, @Controller 어노테이션을 이용하여 구현한 컨트롤러 뿐만 아니라, Controller 인터페이스를 구현한 컨트롤러, 특수 목적으로 사용되는 HttpRequestHandler 인터페이스를 구현한 클래스를 동일한 방식으로 실행할 수 있도록 한다. 실행된 Controller는 리턴할 데이터와 View를 HandlerAdapter에게 리턴한다. Handler Adapter는 데이터와 view를 ModelAndView 형태로 DispatcherServlet에게 리턴한다. 클라이언트에게 보여질 View를 찾는다. ViewResolver 객체가 클라이언트에게 보여질 view를 찾는 역할을 한다. 응답 데이터와 View를 클라이언트에게 전달한다. 최종적으로 ViewResolver 객체가 리턴한 View 객체에 응답 데이터를 넣어 클라이언트에게 리턴한다. ContextLoaderListener 웹 애플리케이션의 규모가 커진다면, 클라이언트의 요청 또한 다양해질 것이고, 이를 처리할, 즉 클라이언트의 요청을 처리하는 역할을 가진 DispatcherServlet도 늘어날 수 있다. 다른 성격을 가진 서블릿을 만들어야 할 수 있으니, 서블릿의 성격에 맞게 설정도 각각 적용시켜야 한다. 그러나 모든 서블릿이 공통으로 가져야 할 설정도 존재한다. 즉 Servlet Context 단위가 아닌, (Web) Application Context 단위의 설정이 필요한데, 이를 ContextLoaderListener 객체가 처리한다. Filter Filter란, 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 부분이다. e.g.) Spring Security Filter가 적용되어 있다면, 인가 및 인증 처리를 먼저 처리한 후 DispatcherServlet에게 요청을 전달할 것이다. e.g.) Encoding Filter가 적용되어 있다면 클라이언트의 요청 데이터를 인코딩하는 작업이 선 처리된 후 DispatcherServlet에게 필터링 된 데이터가 전달된다. ","permalink":"https://blog.litsynp.com/posts/2022/01/21/tir-about-web.xml/","summary":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.","title":"[TIR] About web.xml"},{"content":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages ","permalink":"https://blog.litsynp.com/posts/2022/01/07/tir-redis-vs-kafka-vs-rabbitmq/","summary":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages ","title":"[TIR] Redis vs Kafka vs RabbitMQ"},{"content":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/01/05/drf-serializer%EC%97%90-writable-non-model-field-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/","summary":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow","title":"[DRF] Serializer에 writable non-model field 추가하기"},{"content":"문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인 아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인 아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍","title":"Spring Boot에서 Swagger UI 접속이 안되는 경우"},{"content":"문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-exceptionhandler-method-mapped-for-xxxexception/","summary":"문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF Stack Overflow","title":"Getting Ambiguous @ExceptionHandler method mapped for XXXException"},{"content":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.\u0026#39;} return Response(response, status=status.HTTP_403_FORBIDDEN) 아무튼 예시에 간략하게 설명을 덧붙이자면, 다음과 같다.\n제시한 destroy 함수는 DRF의 ModelViewSet 를 상속한 클래스인 UserViewSet 내의 함수이다. destroy 함수를 override하여 새로운 기능을 제공하고자 한다. 로그인한 사용자의 ID와, URL에 있는 parameter (/users/:pk)의 pk 부분, 즉 조회하려는 사용자의 ID가 일치하는지를 확인한다. 일치하면 super() 를 이용하여 기존 destroy 함수를 호출해 해당 사용자를 DB에서 삭제한다. 일치하지 않으면 HTTP 상태 코드 403 Forbidden와 함께 response 메세지를 JSON으로 반환한다. 참고 위와 같이 작성하면 물론 로그인을 했는지부터 확인해야하기 때문에 permission_classes를 작성해야 한다. 또한, 위의 함수만 작성하면 DRF의 admin site에서는 DELETE 버튼이 비활성화되지 않는다. (물론 클릭하면 권한에 따라 reject 될 것이다) REF Using super with a class method - (Stack Overflow)\n","permalink":"https://blog.litsynp.com/posts/2021/02/10/python-super-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B8%B0%EC%A1%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/","summary":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.","title":"[Python] super() 이용해서 기존 메소드 이용하기"}]