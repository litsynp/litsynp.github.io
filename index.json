[{"content":"About 사이트: 프로그래머스 이름: 사라지는 발판 수준: 3 유형: DFS 출제: 2022 KAKAO BLIND RECRUITMENT 주소: https://programmers.co.kr/learn/courses/30/lessons/92345 해설 최대 사이즈가 크지 않다 (1 \u0026lt;= 가로\u0026amp;세로 길이 \u0026lt;= 5) 움직일 때마다 밟고 있던 발판이 사라진다 라는 조건 덕분에 완전탐색으로 풀어도 문제가 없다.\nDFS로 풀도록 하는데, 다음 조건으로 return 해본다.\n이길 수 있는 케이스가 있다면 그 중에서 최선으로 이기는 케이스를 리턴한다. (승리) 질 수 밖에 없다면 최대한 오래 버티는 케이스를 리턴한다. (패배) board[ax][ay] 를 0으로, B의 턴을 실행하고 나서 결과를 반환받으면 1로 만들어줌으로써 다른 분기를 검사할 수 있도록 한다.\n승자는 가장 빨리 이기는 걸 선택하고, 패자는 최대한 늦게 지는 걸 선택한다.\n모두 이기는 경우 최대한 빨리 이기는 것을, 모두 지는 경우 최대한 늦게 지는 걸 선택한다.\n코드 GitHub\npublic class Q92345 { int[][] board; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int MAX_X; int MAX_Y; public int solution(int[][] board, int[] aloc, int[] bloc) { this.board = board; MAX_X = board.length; MAX_Y = board[0].length; return dfs(aloc[0], aloc[1], bloc[0], bloc[1]); } int dfs(int ax, int ay, int bx, int by) { if (board[ax][ay] == 0) { return 0; } int result = 0; for (int[] dir : dirs) { int nx = ax + dir[0]; int ny = ay + dir[1]; if (isOut(nx, ny) || board[nx][ny] == 0) { continue; } board[ax][ay] = 0; int bMove = dfs(bx, by, nx, ny) + 1; board[ax][ay] = 1; if (result % 2 == 0 \u0026amp;\u0026amp; bMove % 2 == 1) { result = bMove; } else if (result % 2 == 0 \u0026amp;\u0026amp; bMove % 2 == 0) { result = Math.max(result, bMove); } else if (result % 2 == 1 \u0026amp;\u0026amp; bMove % 2 == 1) { result = Math.min(result, bMove); } } return result; } boolean isOut(int x, int y) { return x \u0026lt; 0 || x \u0026gt;= MAX_X || y \u0026lt; 0 || y \u0026gt;= MAX_Y; } } 관련 있는 / 유사한 알고리즘 스프라그-그런디 정리\n미니맥스 알고리즘\nREF 해설\n자바 풀이\n자바 풀이 2\n","permalink":"https://blog.litsynp.com/posts/2022/06/07/programmers-q92345-%EC%82%AC%EB%9D%BC%EC%A7%80%EB%8A%94%EB%B0%9C%ED%8C%90/","summary":"","title":"[프로그래머스][level 3][#92345] 사라지는 발판"},{"content":"About 사이트: 프로그래머스 이름: [3차] 자동완성 수준: LEVEL 4 유형: 문자열 출제: 2018 KAKAO BLIND RECRUITMENT 주소: https://programmers.co.kr/learn/courses/30/lessons/17685 해설 처음에 그래프, 트리 구조를 떠올리고 그렇게 구현해보려 했으나 생각보다 쉽게 안됐다.\n그러다가 참고하게 된 아이디어는 다음과 같다.\n우선 사전순으로 정렬을 한다. 모든 문자열에 대해서 입력해야되는 문자 수를 0으로 초기화한다. 2개씩 묶어서 비교하면 된다. 둘 중에 길이가 작은 것의 길이를 구한다. shorter라고 둔다. 둘 중 처음으로 문자가 달라지는 곳의 위치를 구한다. firstDiff 라고 둔다. 먼저 들어온 문자열에 대해서, 만약 shorter와 firstDiff가 같다면, 입력할 문자 수는 firstDiff 이다. 다르다면 이전에 저장된 값 result[i]와 firstDiff + 1 중 큰 쪽이 입력해야 할 문자의 수다. 나중에 들어온 문자열은 firstDiff + 1 이라고 해둔다. 처음에 듣고 왜 무조건 나중에 들어온 문자열이 firstDiff + 1 인가 고민했다. 중요한 점은 문자열들은 사전 순으로 배열 안에서 정렬이 돼있다는 것이다. 사전 순으로 정렬했다고 길이가 긴 문자열이 뒤로 가는 것은 아니다.\n또한 앞뒤만 뷔교해서 풀 수 있다는 것을 받아들여야 한다. 이해하기 몹시 어렵다. 이 역시도 사전 순으로 정렬돼있기 때문에 가능하다. 그리고 동일한 문자열은 존재하지 않는다는 것이다. 사전순으로 정렬돼있고 동일한 문자열은 존재하지 않기 때문에 앞뒤로만 비교하고 다른 부분만 찾아서 계산하면 된다.\n예시 words가 다음과 같이 들어왔다고 가정하자: [abc, abdf, abdg, ac].\n1번 묶음 abc (0) -\u0026gt; (3) abdf (0) -\u0026gt; (3) 라면, shorter = 3, firstDiff = 2 (c != d)이다. 둘이 다르기 때문에, 먼저 들어온 문자열 abc는 result[i] = 0과 firstDiff + 1 = 3을 비교해 큰 쪽인 3을 입력해야 한다. 나중에 들어온 문자열 abdf는 firstDiff + 1 = 3이다.\n2번 묶음 abdf (3) -\u0026gt; (4) abdg (0) -\u0026gt; (4) 라면, shorter = 4, firstDiff = 3이다. 마찬가지로 먼저 들어온 문자열 abdf는 result[i] = 3과 firstDiff + 1 = 4를 비교해 큰 쪽인 4를 입력한다. 나중에 들어온 문자열 abdg는 firstDiff + 1 = 4이다.\n3번 묶음 abdg (4) -\u0026gt; (4) ac (0) -\u0026gt; (2) 라면, shorter = 2, firstDiff = 1이다. 먼저 들어온 문자열 abdg는 result[i] = 4과 firstDiff + 1 = 2를 비교해 큰 쪽인 4를 입력한다. 나중에 들어온 문자열 ac는 firstDiff + 1 = 2이다.\n정답 따라서 다음과 같다.\nabc = 3 abdf = 4 abdg = 4 ac = 2 답은 3 + 4 + 4 + 2인 13이다.\n참고 아이디어를 공유해준 친구 블로그다. 굉장히 참신한 아이디어인 것 같다. 다른 곳에 구글링해도 안나오는 방식으로 풀었다.\n앱등개발자IOS 블로그\n코드 GitHub\nimport java.util.*; public class Q17685 { public int solution(String[] words) { Arrays.sort(words); int[] result = new int[words.length]; for (int i = 0; i \u0026lt; words.length - 1; i++) { int shorter = Math.min(words[i].length(), words[i + 1].length()); int firstDiff = findFirstDiff(words[i], words[i + 1], shorter); if (shorter == firstDiff) { result[i] = firstDiff; } else { result[i] = Math.max(result[i], firstDiff + 1); } result[i + 1] = firstDiff + 1; } return Arrays.stream(result).sum(); } static int findFirstDiff(String word1, String word2, int len) { int i = 0; for (i = 0; i \u0026lt; len; i++) { char c1 = word1.charAt(i); char c2 = word2.charAt(i); if (c1 != c2) { break; } } return i; } } ","permalink":"https://blog.litsynp.com/posts/2022/06/05/programmers-q17685-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1/","summary":"","title":"[프로그래머스][Level 4][#17685] 자동완성 해설"},{"content":"About 사이트: 프로그래머스 이름: [1차] 캐시 수준: LEVEL 2 유형: 자료구조 출제: 2018 KAKAO BLIND RECRUITMENT 주소: https://programmers.co.kr/learn/courses/30/lessons/17680 해설 LRU 캐시가 무엇인지 친절하게 해설에서 설명을 해줬다. 가장 오래된 데이터를 교체하면 된다.\nLinkedHashSet 을 생각해서 풀 수도 있겠다. 하지만 자바에서 친절하게 LinkedHashMap 에서 removeEldestEntry를 오버라이딩할 수 있도록 제공해서, 이를 오버라이딩하는 것으로 쉽게 풀 수 있다.\nLinkedHashMap을 생성할 때, 매개변수 3개 (코드 참고)를 넣어주는 것이 중요하다.\nLinkedHashMap은 기본적으로 넣은 순서로 정렬되는 insertion-ordered이다. 이걸 접근 순서로 바꾸는 access-ordered (즉, LRU)로 바꾸려면 3번째 변수인 accessOrder에 true를 대입해줘야 한다. 두 번째 매개변수인 loadFactor은 0.75f가 optimal한 편이니 0.75f를 넣어주면 된다. (물론 달리 해도 동작은 한다. 참고 링크를 참고할 것)\n그리고 cache.get()를 반드시 넣어줘야 access 했는지를 LinkedHashMap 이 알 수 있다. containsKey()는 접근으로 안 쳐주는 것으로 보인다.\n캐시 사이즈가 0이면 저장이 안되는 조건을 처음에 놓치긴 했는데, 효율성의 문제지 빼도 작동은 할 것이다.\n참고 StackOverflow - LinkedHashMap ordering\nStackOverflow - why is loadFactor in HashMap is set to 0.75 by default? [duplicate]\n코드 GitHub\nimport java.util.*; public class Q17680 { public int solution(int cacheSize, String[] cities) { int answer = 0; // 캐시 사이즈 0이면 저장이 안됨 if (cacheSize == 0) { return cities.length * 5; } LRUCache cache = new LRUCache(cacheSize); for (String city : cities) { answer += cache.execute(city); } return answer; } // LRU: Least Recently Used class LRUCache { Map\u0026lt;String, Integer\u0026gt; cache; final int cacheSize; public LRUCache(int _cacheSize) { cacheSize = _cacheSize; // true를 줌으로써 \u0026#34;insertion-ordered\u0026#34;가 아닌 \u0026#34;access-ordered\u0026#34; map으로 바꾼다. cache = new LinkedHashMap\u0026lt;\u0026gt;(cacheSize, 0.75f, true) { @Override protected boolean removeEldestEntry(java.util.Map.Entry\u0026lt;String, Integer\u0026gt; eldest) { // capacity보다 크면 가장 오래된 데이터를 자동으로 삭제 return size() \u0026gt; cacheSize; } }; } public int execute(String in) { in = in.toLowerCase(); if (cache.containsKey(in)) { // cache hit cache.get(in); return 1; } else { cache.put(in, 0); return 5; } } } } ","permalink":"https://blog.litsynp.com/posts/2022/06/05/programmers-q17680-%EC%BA%90%EC%8B%9C/","summary":"","title":"[프로그래머스][Level 2][#17680] 캐시 해설"},{"content":"About 사이트: 프로그래머스 이름: [3차] 파일명 정렬 수준: LEVEL 2 유형: 문자열 출제: 2018 KAKAO BLIND RECRUITMENT 주소: https://programmers.co.kr/learn/courses/30/lessons/17686 해설 정규표현식을 잘 구글링해서 풀었다. 솔직히 깔끔한 방법은 아니다.\n(?\u0026lt;=\\\\D)(?=\\\\d)라는 정규표현식으로 숫자가 아닌 문자열과 숫자로 시작하는 문자열을 나눈다.\n숫자로 시작하는 문자열은 다시 \\\\d+로 숫자만 걸러준다. 그 외의 부분은 버려도 좋다.\n* 참고로, matcher.group()를 사용하면 match 결과 전체를 준다. 그룹을 지정했다면 매개변수로 그룹의 숫자를 넣어주면 된다.\n그렇게 List에 하나씩 add 해주고, 나중에 정렬을 진행해 순서대로 반환한다.\n정렬 기준은 클래스에서 Comparable 인터페이스를 implement 하고 compareTo를 오버라이딩하였다. 문제의 정의대로 순서대로 비교해주면 된다.\n코드 GitHub\nimport java.util.*; import java.util.regex.*; public class Q17686 { public String[] solution(String[] files) { List\u0026lt;Node\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; files.length; i++) { String[] part = files[i].split(\u0026#34;(?\u0026lt;=\\\\D)(?=\\\\d)\u0026#34;); String head = part[0]; String number = \u0026#34;\u0026#34;; Pattern pattern = Pattern.compile(\u0026#34;\\\\d+\u0026#34;); Matcher matcher = pattern.matcher(part[1]); if (matcher.find()) { number = matcher.group(); } Node node = new Node(i, files[i], head, number); list.add(node); } Collections.sort(list); return list.stream().map(n -\u0026gt; n.orig).toArray(String[]::new); } static class Node implements Comparable\u0026lt;Node\u0026gt; { int idx; String orig; String head; String number; @Override public String toString() { return \u0026#34;Node{\u0026#34; + \u0026#34;idx=\u0026#34; + idx + \u0026#34;, head=\u0026#39;\u0026#34; + head + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, number=\u0026#39;\u0026#34; + number + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } public Node(int idx, String orig, String head, String number) { this.idx = idx; this.orig = orig; this.head = head.toLowerCase(); this.number = number; } @Override public int compareTo(Node o) { int order1 = this.head.compareTo(o.head); if (order1 != 0) { return order1; } int i1 = Integer.parseInt(this.number); int i2 = Integer.parseInt(o.number); int order2 = Integer.compare(i1, i2); if (order2 != 0) { return order2; } return Integer.compare(this.idx, o.idx); } } } ","permalink":"https://blog.litsynp.com/posts/2022/06/05/programmers-q17686-%ED%8C%8C%EC%9D%BC%EB%AA%85%EC%A0%95%EB%A0%AC/","summary":"","title":"[프로그래머스][Level 2][#17686] 파일명 정렬 해설"},{"content":"About 사이트: 프로그래머스 이름: [1차] 프렌즈4블록 수준: LEVEL 2 유형: 구현 출제: 2018 KAKAO BLIND RECRUITMENT 주소: https://programmers.co.kr/learn/courses/30/lessons/17679 참고 참고 블로그\n해설 주석을 달아두어 이해하기 쉬울 것이다.\nenum, BFS, DFS를 처음에 생각했으나, 생각보다 단순하게 접근하면 되는 문제였다.\n블록은 한번에 삭제되는 것이 아니라 4칸의 영역이 겹칠 수 있다. 따라서 따로 checked 라는 것을 둘 것이다.\n문자를 넣어둘 map과, 삭제할 블록의 위치를 담아두는 checked를 둔다.\n그리고 다음의 순서로 진행한다.\n모든 블록에 대해서, 빈 칸이 아닐 경우에 주변 4개를 검사한다. 주변 4개를 검사해서 같은 블록이 있다면 check 해둔다.\n다시 모든 블록에 대해서, check된 좌표를 삭제한다. 삭제한 개수는 따로 저장해둔다.\n삭제된 것이 하나도 없다면 종료한다. 삭제된 것이 있다면 answer에 개수를 더한다.\n삭제된 것이 있다면 중간 중간 빈칸이 생겼을텐데, 빈칸에 대해서는 블록을 하나씩 내려준다.\n코드 GitHub\npublic class Q17679 { public int solution(int m, int n, String[] board) { char[][] map = new char[m][n]; for (int i = 0; i \u0026lt; m; i++) { map[i] = board[i].toCharArray(); } int answer = 0; // m: 세로 길이 // n: 가로 길이 while (true) { // 삭제할 블록 수 int count = checkBlock(m, n, map); // 삭제한 블록이 없다면 종료 if (count == 0) { break; } answer += count; // 빈 칸이 생겼다면 내려보냄 dropBlock(m, n, map); } return answer; } static int checkBlock(int m, int n, char[][] map) { int count = 0; boolean[][] checked = new boolean[m][n]; // 모든 블록에 대해서 for (int r = 0; r \u0026lt; m - 1; r++) { for (int c = 0; c \u0026lt; n - 1; c++) { // 비어있으면 지나감 if (map[r][c] == \u0026#39;.\u0026#39;) { continue; } // 비어있지 않다면 인접한 4칸 검사 // 인접한 같은 종류의 4 블록이 있다면 check = true checkFour(map, checked, r, c); } } // 체크된 블록을 모두 빈 칸으로 만듦 for (int r = 0; r \u0026lt; m; r++) { for (int c = 0; c \u0026lt; n; c++) { if (checked[r][c]) { // 빈칸이 된 블록 = \u0026#34;삭제할 블록\u0026#34; count++; map[r][c] = \u0026#39;.\u0026#39;; } } } // 삭제할 블록 개수 반환 return count; } static void dropBlock(int m, int n, char[][] map) { for (int c = 0; c \u0026lt; n; c++) { // 맨 아랫줄부터 좌-\u0026gt;우 검사 for (int r = m - 1; r \u0026gt;= 0; r--) { // 비어있는 공간이 있다면 if (map[r][c] == \u0026#39;.\u0026#39;) { // 위로 한칸씩 올라가면서 블록을 찾으면 밑으로 내림 for (int nr = r - 1; nr \u0026gt;= 0; nr--) { if (map[nr][c] != \u0026#39;.\u0026#39;) { map[r][c] = map[nr][c]; map[nr][c] = \u0026#39;.\u0026#39;; break; } } } } } } static void checkFour(char[][] map, boolean[][] checked, int r, int c) { // 현재 블록 종류 char block = map[r][c]; // 현재 블록을 포함해서 같은 종류의 블럭 4개가 인접한지 체크 // X: 현재 블록, O: 검사할 인접한 블록 // XO // OO // 의 방향으로만 검사 for (int x = r; x \u0026lt;= r + 1; x++) { for (int y = c; y \u0026lt;= c + 1; y++) { if (map[x][y] != block) { return; } } } // 모두 인접하다면 check for (int x = r; x \u0026lt;= r + 1; x++) { for (int y = c; y \u0026lt;= c + 1; y++) { checked[x][y] = true; } } } } ","permalink":"https://blog.litsynp.com/posts/2022/06/05/programmers-q17679-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/","summary":"","title":"[프로그래머스][Level 2][#17679] 프렌즈4블록 해설"},{"content":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다. JobBuilderFactory로 원하는 Job을 만들 수 있다. JobBuilderFactory의 get() 메서드로 JobBuilder를 생성하고 이를 응용하면 된다. org.springframework.batch.core.Configuration.annotation.JobBuilderFactory의 내부 코드이다. (길다 길어!)\n// org.springframework.batch.core.Configuration.annotation.JobBuilderFactory public class JobBuilderFactory { private JobRepository jobRepository; public JobBuilderFactory(JobRepository jobRepository) { this.jobRepository = jobRepository; } public JobBuilder get(String name) { JobBuilder builder = new JobBuilder(name).repository(jobRepository); return builder; } } get() 메서드를 호출할 때마다 새로운 JobBuilder 인스턴스를 반환한다. 그리고 매번 생성할 때마다 JobBuilderFactory 를 생성할 때 주입받은 JobRepository 를 사용할 repository로 설정한다. 즉, 해당 JobBuilderFactory 에서 생성되는 모든 JobBuilder 가 동일한 리포지토리를 사용한다.\n아래는 JobBuilder 코드 일부이다.\n// org.springframework.batch.core.job.builder.JobBuilder // ... public SimpleJobBuilder start(Step step) { return new SimpleJobBuilder(this).start(step); } public JobFlowBuilder start(Flow flow) { return new JobFlowBuilder(this).start(flow); } public JobFlowBuilder flow(Step step) { return new JobFlowBuilder(this).start(step); } // ... 공통점은 모두 빌더를 반환한다는 점이다. JobBuilder은 Job을 직접 생성하는 것이 아닌 별도의 구체적인 빌더를 만들어 반환한다. 이렇게 빌더를 생성하게끔 하는 이유는, 경우에 따라 Job 생성 방법이 다르기 때문이다. 구체적인 빌더를 구현하고 이를 통해 Job 생성이 이루어지게 하는 의도로 파악된다.\n빌더를 받아 사용해야 하므로 불편해보이지만, 메서드 체인 방식을 이용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있다.\n메서드를 살펴보면 Job을 생성하기 위한 Step 또는 Flow를 파라미터로 받아 구체적인 빌더를 생성하고 있다. Job은 Step 또는 Flow 인스턴스의 컨테이너 역할을 하기 때문에 생성하기 전에 인스턴스를 전달받는다.\n다음은 Job 생성 예제 코드이다.\n@Autowired private JobBuilderFactory jobBuilderFactory; @Bean public Job simpleJob() { return jobBuilderFactory.get(\u0026#34;simpleJob\u0026#34;) // \u0026#39;simpleJob\u0026#39; 이라는 이름을 가진 Job을 생성할 수 있는 `JobBuilder` 객체 인스턴스 반환 .start(simpleStep()) // `simpleStep()`은 간단한 `Step` 인스턴스를 생성해 반환하는 메서드라 가정한다. `start()` 메서드로 인해 생성되는 빌더는 `SimpleJobBuilder` .build(); // \u0026#39;simpleJob\u0026#39;이라는 이름을 가진 `Job`이 생성되어 반환 } JobInstance JobInstance 는 배치에서 Job 이 실행될 때 하나의 Job 실행 단위이다. 만약 하루에 한 번씩 배치의 Job 이 실행된다면, 어제와 오늘 실행한 각각의 Job을 JobInstance 라고 부를 수 있다.\n그렇다면 각각의 JobInstance 는 하나의 JobExecution (JobInstance에 대한 한 번의 실행을 나타내는 객체)을 갖고 있을까? 그렇지 않다.\n오늘 Job을 실행했는데 실패했다면 다음날 동일한 JobInstance 를 가지고 또 실행한다. Job 실행이 실패하면 JobInstance 가 끝난 것으로 간주하지 않기 때문이다.\n그러면 JobInstance 는 어제의 실패한 JobExecution 과 오늘 성공한 JobExecution 두 개를 갖게 된다. 즉, JobExecution을 여러 개 가질 수 있다.\nJobExecution JobExecution 은 JobInstance에 대한 한 번의 실행을 나타내는 객체이다.\n위의 예제를 그대로 가져와 설명하자면, 만약 오늘의 Job이 실패해 내일 다시 동일한 Job 을 실행하면 오늘, 내일의 실행 모두 같은 JobInstance 를 사용할 것이다. 단, 오늘, 내일의 실행은 각기 다른 JobExecution 을 생성한다.\nJobExecution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체라는 것을 알 수 있다. JobExecution 은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때의 메시지 등의 정보를 담고 있다.\n다음은 JobExecution 내부의 코드이다.\n// org.springframework.batch.core.JobExecution public class JobExecution extends Entity { private final JobParameters jobParameters; private JobInstance jobInstance; private volatile Collection\u0026lt;StepExecution\u0026gt; stepExecutions = Collections.synchronizedSet(new LinkedHashSet\u0026lt;\u0026gt;()); private volatile BatchStatus status = BatchStatus.STARTING; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN; private volatile ExecutionContext executionContext = new ExecutionContext(); private transient volatile List\u0026lt;Throwable\u0026gt; failureExceptions = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private final String jobConfigurationName; // ... } jobParameters : Job 실행에 필요한 매개변수 데이터. jobInstance : Job 실행의 단위가 되는 객체. stepExecutions : StepExecution을 여러 개 가질 수 있는 Collection 타입. status : Job의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING) startTime : Job 이 실행된 시간. null 이면 시작하지 않았다는 뜻. createTime : JobExecution 이 생성된 시간. endTime : JobExecution이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. exitStatus : Job 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN) executionContext : Job 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. failureExceptions : Job 실행 중 발생한 예외를 List 에 넣어둔다. jobConfigurationName : Job 설정 이름. JobParameters JobParameters 는 Job 이 실행될 때 필요한 파라미터들을 Map 타입으로 저장하는 객체이다.\nJobParameters 는 JobInstance 를 구분하는 기준이 되기도 한다. 예를 들어 Job 하나를 생성할 때, 시작 시간 등의 정보를 파라미터로 해서 하나의 JobInstance 를 생성한다.\n즉, JobInstance와 JobParameters 는 1:1 관계이다. 파라미터의 타입으로는 String , Long , Date , Double 을 사용할 수 있다.\nStep Step은 실질적인 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있는 도메인 객체이다. Job 을 처리하는 실질적인 단위로 쓰인다.\n모든 Job 에는 1개 이상의 Step이 있어야 한다.\nStepExecution Job 에 JobExecution 이라는 Job 실행 정보가 있다면, Step에는 StepExecution 이라는 Step 실행 정보를 담는 객체가 있다. 각각의 Step 이 실행될 때마다 StepExecution 이 생성된다.\n다음은 StepExecution 클래스이다.\npublic class StepExecution extends Entity { private final JobExecution jobExecution; private final String stepName; private volatile BatchStatus status = BatchStatus.STARTING; private volatile long readCount = 0; private volatile long writeCount = 0; private volatile long commitCount = 0; private volatile long rollbackCount = 0; private volatile long readSkipCount = 0; private volatile long processSkipCount = 0; private volatile long writeSkipCount = 0; private volatile Date startTime = null; private volatile Date createTime = new Date(System.currentTimeMillis()); private volatile Date endTime = null; private volatile Date lastUpdated = null; private volatile ExecutionContext executionContext = new ExecutionContext(); private volatile ExitStatus exitStatus = ExitStatus.EXECUTING; private volatile boolean terminateOnly; private volatile long filterCount; private transient volatile List\u0026lt;Throwable\u0026gt; failureExceptions = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); // ... } jobExecution : 현재의 JobExecution 정보. stepName : Step의 이름. status : Step 의 실행 상태. (COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 등이 있다. default는 STARTING.) readCount : 성공적으로 읽은 레코드 수. writeCount : 성공적으로 쓴 레코드 수. commitCount : Step의 실행에 대해 커밋된 트랜잭션 수. rollbackCount : Step의 실행에 대해 롤백된 트랜잭션 수. readSkipCount : 읽기에 실패해 건너뛴 레코드 수. processSkipCount : 프로세스가 실패해 건너뛴 레코드 수. writeSkipCount : 쓰기에 실패해 건너뛴 레코드 수. startTime : Step이 실행된 시간. null이면 시작하지 않았다는 뜻. endTime : Step의 실행 성공 여부와 관련 없이 Step이 끝난 시간. lastUpdated : 마지막으로 수정된 시간. executionContext : Step 실행 사이에 유지해야 하는 사용자 데이터가 들어 있다. exitStatus : Step 실행 결과에 대한 상태. (UNKNOWN, EXECUTING, COMPLETED, NOOP, FAILED, STOPPED 등이 있다. default는 UNKNOWN.) terminateOnly : Job 실행 중지 여부. filterCount : 실행에서 필터링된 레코드 수. failureExceptions : Step 실행 중 발생한 예외를 List 타입으로 저장한다. JobRepository JobRepository 는 배치 처리 정보를 담고 있는 메커니즘이다. 어떤 Job이 실행되었으며, 몇 번 실행되었고, 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장한다.\n예를 들어 Job 하나가 실행되면 JobRepository 에서는 배치 실행에 관련된 정보를 담고 있는 도메인인 JobExecution 을 생성한다.\nJobRepository 는 Step 의 실행 정보를 담고 있는 StepExecution 도 저장소에 저장하며, 전체 메타데이터를 저장 및 관리하는 역할을 한다.\nJobLauncher JobLauncher 는 Job , JobParameters 와 함께 배치를 실행하는 인터페이스이다. 인터페이스는 run() 하나이다.\n// org.springframework.batch.core.launch.JobLauncher public interface JobLauncher { public JobExecution run(Job job, JobParameters jobParameters) throws ... } 매개변수로 Job과 JobParameters를 받아 JobExecution을 반환한다. 매개변수가 이전과 동일하면서 이전에 JobExecution이 중단된 적 있다면 동일한 JobExecution을 반환한다.\nItemReader ItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스이다. 파일, XML, CSV, DB 등 여러 타입의 데이터를 읽어올 수 있다.\n// org.springframework.batch.item.ItemReader public interface ItemReader\u0026lt;T\u0026gt; { T read() throws Exception, UnexpectedException, ParseException, NonTransientResourceException; } ItemReader 에서 read() 메서드의 반환 타입을 제네릭 \u0026lt;T\u0026gt; 으로 구성했기 때문에 직접 타입을 지정할 수 있다.\n위에서 설명한 읽기-처리-쓰기에서 읽기를 담당한다고 볼 수 있겠다!\nItemProcessor ItemProcessor 는 ItemReader 로 읽어온 배치 데이터를 변환하는 역할을 수행한다.\n읽기-처리-쓰기 에서 처리를 담당한다고 볼 수 있겠다.\n굳이 ItemWriter가 아니라 ItemProcessor라는 인터페이스를 분리한 이유는 두 가지다.\n비즈니스 로직을 분리하기 위해서이다. 각각 읽기-처리-쓰기를 담당하게 해 역할을 명확히 분리한다. Input의 타입과 Output의 타입이 다를 수 있다. Input과 Output의 타입이 ItemProcesor의 제네릭 \u0026lt;I, O\u0026gt;에 들어가게 되니 더 직관적이다. // org.springframework.batch.item.ItemProcesor public interface ItemProcessor\u0026lt;I, O\u0026gt; { O process(I item) throws Exception; } ItemWriter ItemWriter 는 배치 데이터를 저장한다. 일반적으로 DB 또는 파일에 저장한다.\n읽기-처리-쓰기에서 마지막 단계인 쓰기를 담당한다.\n// org.springframework.batch.item.ItemWriter public interface ItemWriter\u0026lt;T\u0026gt; { void write(List\u0026lt;? extends T\u0026gt; items) throws Exception; } ItemWriter은 ItemReader와 비슷한 방식으로 구현하면 된다.\nwrite() 메서드는 List 자료구조를 이용해 지정한 타입의 리스트를 매개변수를 받는다. 리스트의 데이터 수는 설정한 청크 (chunk) 단위로 불러온다.\nwrite() 메서드는 void 함수라서 반환 값은 따로 없다. 매개변수로 받은 데이터를 저장하는 로직만을 구현하면 된다.\nREF \u0026lt;처음 배우는 스프링 부트 2\u0026gt; - 김영재 저\nGitHub - spring-batch\nSpring Doc - Spring Batch\n","permalink":"https://blog.litsynp.com/posts/2022/06/04/spring-batch-summary/","summary":"배치 개발 시나리오 배치의 일반적인 시나리오는 읽기 - 처리 - 쓰기로 나누어진다.\n배치 관련 객체 관계도 Job과 Step은 1:M, Step과 ItemReader, ItemProcessor, ItemWriter는 1:1 관계를 갖는다.\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현한다.\n배치 관련 클래스 정의 Job Job 은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체이다. 전체 배치 처리에 있어 항상 최상단 계층에 있다. Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너다.\nJob 객체를 만드는 빌더는 여러 개가 있다.","title":"Spring Batch와 주요 클래스 정리"},{"content":"클린 코더 (The Clean Coder) 독서 - 1 음악 들으면서 About 저자: “밥 아저씨” 로버트 C. 마틴\n\u0026lt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신\u0026gt;의 저자이기도 함\n표지 사진은 M1 성운 (게 성운)이고, 푸른 색의 밝은 점은 펄서이다.\n책에서 다루는 내용 프로 소프트웨어 개발자의 마음가짐, 즉 소프트웨어 프로페셔널리즘에 관한 책이다.\n책임지는 일은 무서운 일이다. 기술자라면 시스템과 프로젝트에 대해 관리자는 알기 힘든 깊은 지식을 알아야 한다. 그 지식을 가지고 행동으로 옮겨야 할 책임이 있다.\n미리 읽어두기 프로 프로그래머란 책에서 내리는 “프로 프로그래머”의 정의란, 태도 attitude, 원칙 discipline, 행동 action 이 프로의 핵심이다.\n… 천공카드 (Punched Card)란? -\u0026gt; 720비트 천공카드\n정해진 위치에 구멍이 뚫려 있는지 아닌지로 2진법 데이터를 기록한 카드.\nOMR 카드의 시초라고 할 수 있다. 입력장치이자 기억장치가 된다.\n1991년에 출시한 게임인 스트리트 파이터 2를 천공카드로 프로그래밍하면 약 81,500 장의 천공카드를 사용해야 한다고 한다. (대단한데?)\n천공카드가 쓰이던 시절에는 주로 코볼과 포트란이 대표적으로 사용됐다고 한다. 언어 자체적으로 80 컬럼에 맞춰 코딩하도록 되어 있다고 한다. 그리고 코딩의 편의를 제공하도록 미리 인쇄된 코딩 용지 (Coding Form)이 있다고 한다. 아래와 같이 생겼다.\n로버트 마틴은 코딩 양식지 (Coding Form을 의미하는 듯 하다)에 인쇄 활자체 대문자 (e.g., ABC)로 쓰고, 연필을 2번 사용했다고 한다.\n코딩 양식지는 천공기사 (Keypunch Operator / 또는 좀 더 포괄적으로 Data Entry Clerk)에게 전달되어, 서류 접수함에서 코딩 양식지를 꺼내, 키 펀치 기계(Keypunch, 타자기와 비슷하지만 종이에 글자를 찍는 게 아니라 카드에 구멍을 뚫는다)로 “타이핑” 해서 넣었다고 한다. (펀치하다 는 동사를 써도 되지 않을까?)\n다음에 계속 책 더 읽으면 더 작성 예정!\n","permalink":"https://blog.litsynp.com/posts/2022/05/27/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94-the-clean-coder-%EB%8F%85%EC%84%9C-1/","summary":"클린 코더 (The Clean Coder) 독서 - 1 음악 들으면서 About 저자: “밥 아저씨” 로버트 C. 마틴\n\u0026lt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신\u0026gt;의 저자이기도 함\n표지 사진은 M1 성운 (게 성운)이고, 푸른 색의 밝은 점은 펄서이다.\n책에서 다루는 내용 프로 소프트웨어 개발자의 마음가짐, 즉 소프트웨어 프로페셔널리즘에 관한 책이다.\n책임지는 일은 무서운 일이다. 기술자라면 시스템과 프로젝트에 대해 관리자는 알기 힘든 깊은 지식을 알아야 한다. 그 지식을 가지고 행동으로 옮겨야 할 책임이 있다.","title":"클린 코더 (The Clean Coder) 독서 - 1"},{"content":"Java - List\u0026lt;Integer\u0026gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.\nimport java.util.*; // ... 중략 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.\nboolean remove(Object o); \u0026ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)\nE remove(int index); \u0026ndash; index번째 원소를 삭제 (index 번째 원소가 없다면 java.lang.IndexOutOfBoundsException 발생)\n당연한 거지만 List\u0026lt;Integer\u0026gt;를 만들었더라도, remove에서 int로 의도한 게 아니라면 remove 메소드 실행 간에 wrapping을 해줘야한다.\n또한 후자는 index 번째 원소가 없다면 Exception까지 발생하니 유의가 필요하다!\nSolution 상황과 용도에 맞게 인자를 넘겨주는 것이 바람직하다.\nREF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2022/05/06/java-listinteger%EC%97%90%EC%84%9C-remove%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C-%EA%B0%84-%EC%A3%BC%EC%9D%98%EC%A0%90/","summary":"Java - List\u0026lt;Integer\u0026gt;에서 remove()를 이용한 원소 삭제 간 주의점 Problem 다음 두 코드는 큰 차이가 있다.\nimport java.util.*; // ... 중략 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(2); System.out.println(list); // [1, 2] import java.util.*; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); list.add(3); list.remove(Integer.valueOf(2)); // 또는 (Integer) 2 System.out.println(list); // [1, 3] java.util.List 에서 remove의 signature는 두 가지이다.\nboolean remove(Object o); \u0026ndash; 원소가 있다면 삭제 (true), 없다면 false (오류 발생 X)","title":"Java - List\u003cInteger\u003e에서 remove()를 이용한 원소 삭제 간 주의점"},{"content":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.\n이런 식으로 실전에서 맞아야 할 몇 문제를 더 틀렸을 수도 있었을 것 같다\u0026hellip;\n주의 해야겠다!\n","permalink":"https://blog.litsynp.com/posts/2022/04/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%A0%95%EB%8B%B5%EC%9D%B4-%EB%A7%9E%EB%8A%94%EB%8D%B0-%EC%95%84%EB%AC%B4%EB%A6%AC-%ED%95%B4%EB%8F%84-test-case%EC%97%90%EC%84%9C-%EC%98%A4%EB%A5%98%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우 프로그래머스에서 문제를 푸는데 아무리 해도 정답이 맞지 않는 경우가 있다.\n그건 어쩌면 logic이 틀린게 아니라 변수 초기화 시점이 잘못됐을 수도 있다.\nstatic을 이용해 전역으로 설정하고 있었다면,\n참고를 보면 answer = 0 초기화를 선언 시가 아닌 solution 안에서 진행해야 테스트케이스 오류가 나지 않음을 알 수 있다.\n추측으로는 이전의 테스트 케이스 진행 중 answer 의 값이 이전 테스트 케이스에서 영향을 받은 걸지도 모르겠다.","title":"프로그래머스에서 정답이 맞는데 아무리 해도 Test Case에서 오류나는 경우"},{"content":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\nGradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.. ) 글을 읽어보고 src/docs/asciidoc/ 경로에 index.adoc 파일을 만들어본다.\n두 번째 이슈 - Gradle 7과 asciidoc의 문제 Spring Initializr을 이용하여 스프링 부트 프로젝트를 만든 상태였고, 자동으로 org.asciidoctor.convert 플러그인이 설정된 상황이었다.\n그런데 ./gradlew asciidoctor을 실행했을 때 나오는 오류가 다음과 같았다.\nIn plugin \u0026#39;org.asciidoctor.convert\u0026#39; type \u0026#39;org.asciidoctor.gradle.AsciidoctorTask\u0026#39; method \u0026#39;asGemPath()\u0026#39; should not be annotated with: @Optional, @InputDirectory. 구글링을 통해 찾아보니, Gradle 7과는 해당 플러그인이 현재 호환이 되지 않는 것으로 판단되었다.\n선택 가능한 방법은 다음과 같다.\nGradle의 버전을 6 이하의 버전으로 낮춘다.\n오류를 잘 수정해본다.\nGradle 7을 현재 사용 중이기 때문에 1번과 같이 그냥 버전을 낮추는 건 찜찜했다. 따라서 오류를 잘 수정해보기로 했다.\n찾아봐도 어떻게 고쳐야되는지 예제가 잘 안나오지만, 결국 GitHub에서 되는 예제를 찾았다!\n다음과 같이 진행하면 된다.\nplugins { // ... id(\u0026#34;org.asciidoctor.jvm.convert\u0026#34;) version \u0026#34;3.3.2\u0026#34; } val asciidoctorExtensions: Configuration by configurations.creating dependencies { // ... asciidoctorExtensions(\u0026#34;org.springframework.restdocs:spring-restdocs-asciidoctor\u0026#34;) } // ... tasks.clean { delete(\u0026#34;src/main/resources/static/docs\u0026#34;) } tasks.test { systemProperty(\u0026#34;org.springframework.restdocs.outputDir\u0026#34;, snippetsDir) outputs.dir(snippetsDir) } tasks.build { dependsOn(\u0026#34;copyDocument\u0026#34;) } tasks.asciidoctor { dependsOn(tasks.test) attributes( mapOf(\u0026#34;snippets\u0026#34; to snippetsDir) ) inputs.dir(snippetsDir) doFirst { delete(\u0026#34;src/main/resources/static/docs\u0026#34;) } } tasks.register(\u0026#34;copyDocument\u0026#34;, Copy::class) { dependsOn(tasks.asciidoctor) from(tasks.asciidoctor.get().outputDir) into(file(\u0026#34;src/main/resources/static/docs\u0026#34;)) } tasks.bootJar { dependsOn(tasks.asciidoctor) from(tasks.asciidoctor.get().outputDir) { into(\u0026#34;BOOT-INF/classes/static/docs\u0026#34;) } } REF Spring REST Docs in General Spring REST Docs + Kotlin 예제\n‘Gradle Kotlin DSL’ 이야기\nTroubleshooting 첫 번째 이슈\nhttps://blog.naver.com/PostView.naver?blogId=qjawnswkd\u0026amp;logNo=222409742108\u0026amp;parentCategoryNo=\u0026amp;categoryNo=41\u0026amp;viewDate=\u0026amp;isShowPopularPosts=false\u0026amp;from=postView\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.. )\n두 번째 이슈\n[Spring] Spring rest docs 적용기(gradle 7.0.2)\n결론으로, 다음 GitHub에 올라온 이슈에서의 build.gradle.kts를 따라하여 해결\nConfigure a Gradle 7 compatible version of Asciidoctor\u0026rsquo;s Gradle plugin in projects using REST Docs #676 ","permalink":"https://blog.litsynp.com/posts/2022/04/08/troubleshooting-spring-boot-+-spring-rest-docs-+-kotlin-+-gradle-7/","summary":"Spring REST Docs 설정하기 Spring REST Docs를 설정하고 싶은데, Gradle 7, Kotlin, build.gradle.kts를 사용하는 예제를 찾아보기 어려웠다.\nKotlin을 사용하는 Spring Boot에서, 다음 환경으로 진행한다.\nGradle 7 Gradle Kotlin DSL을 사용하는 build.gradle.kts 사용 첫 번째 이슈 - index.adoc 생성 어찌저찌 테스트 코드를 작성하고 빌드하면 테스트 코드에 따라 build/generated-snippets 경로 안에 *.adoc 파일들이 생성된다.\n하지만 index.html 파일이 생성되지 않았다.\n예제를 대충 읽었기 때문에 놓친 부분이 있었는데, index.adoc 파일을 작성해야 했다.\nSpring Boot | REST Docs 적용하기 ( + build failed 해결.","title":"Troubleshooting Spring Boot + Spring REST Docs + Kotlin + Gradle 7"},{"content":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다. 이 과정에서 stop-the-world가 발생한다. 이후 Mark 되어있지 않은 객체들을 힙에서 제거하는 과정이 Sweep이다. Reachability Java의 GC는 가비지 객체를 판별하기 위해 reachability 라는 개념을 사용한다. reachable은 Stack에서 Heap 영역의 객체에 대해 참조 할 수 있는지를 뜻한다. 어떤 객체에 유효한 참조가 있으면 reachable, 없으면 unreachable로 구별한다. unreachable 객체를 가비지로 간주한다. JVM의 Heap은 Young, Old, Perm 세 영역으로 나뉜다. Young 영역에서 발생한 GC를 Minor GC, 나머지 두 영역에서 발생한 GC를 Major GC(Full GC)라고 한다. Young (Generation) 영역: 새롭게 생성한 객체가 위치한다. 대부분의 객체가 금방 unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다. Old (Generation) 영역: Young 영역에서 reachable 상태를 유지해 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. Perm 영역: Method Area라고도 한다. 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역이다. REF https://d2.naver.com/helloworld/1329\nhttps://velog.io/@litien/가비지-컬렉터GC\n","permalink":"https://blog.litsynp.com/posts/2022/02/12/java-garbage-collector-in-jvm/","summary":"Garbage Collection 가비지 컬렉션 (Garbage Collection, GC) stop-the-world GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 뜻한다. stop-the-world가 발생하면 GC를 실행하는 thread를 제외한 나머지 thread는 모두 작업을 멈춘다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것을 뜻한다. Java에서는 프로그램 코드로 (null 할당, System.gc() 호출, \u0026hellip;) 메모리를 명시적으로 해제할 필요가 없다. GC의 과정을 Mark and Sweep이라고도 한다. GC가 스택의 모든 변수, 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정을 Mark라고 한다.","title":"[Java] Garbage Collector in JVM"},{"content":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.\nimport org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service @RequiredArgsConstructor public class ExterrnalApiService { private final WebClient.Builder webClientBuilder; public ResponseEntity\u0026lt;?\u0026gt; get() { return webClientBuilder.baseUrl(\u0026#34;https://randomuser.me\u0026#34;).build() .get() .uri(\u0026#34;/api\u0026#34;) .retrieve() .toEntity(Object.class) // Response DTO Type .block(); } public ResponseEntity\u0026lt;?\u0026gt; create() { return webClientBuilder.baseUrl(\u0026#34;https://gorest.co.in\u0026#34;).build() .post() .uri(\u0026#34;/public/v2/users\u0026#34;) .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer AAA.BBB.CCC\u0026#34;) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .bodyValue(new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;email\u0026#34;, \u0026#34;abdasdfc@tesat.com\u0026#34;); put(\u0026#34;name\u0026#34;, \u0026#34;abc\u0026#34;); put(\u0026#34;gender\u0026#34;, \u0026#34;male\u0026#34;); put(\u0026#34;status\u0026#34;, \u0026#34;active\u0026#34;); }}) .retrieve() .toEntity(Object.class) .block(); } } * Used https://randomuser.me and https://gorest.co.in for external API testing.\nREF https://stackoverflow.com/questions/42365266/call-another-rest-api-from-my-server-in-spring-boot\nhttps://bravenamme.github.io/2021/01/07/web_client/\n","permalink":"https://blog.litsynp.com/posts/2022/02/11/spring-boot-external-api-call/","summary":"RestTemplate is commonly used for external API call in Spring.\nBut from Spring 5, WebClient in WebFlux is preferred over RestTemplate.\nFirst, add this dependency to build.gradle.\n// build.gradle // ... implementation \u0026#39;org.springframework.boot:spring-boot-starter-webflux\u0026#39; // ... Then create a bean to inject into different classes.\npackage com.litsynp.application.domain.global.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder getWebClientBuilder() { return WebClient.builder(); } } Finally, inject WebClientBuilder into the service and build the web client to call the external API.","title":"[Spring Boot] External API Call"},{"content":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.\n요청을 직접 처리하지 않고 적절한 객체에게 역할을 위임하여 클라이언트의 요청을 처리한다.\n요청을 처리하기 위해서 크게 4가지 일이 진행되어야 한다.\n클라이언트의 요청을 처리해줄 컨트롤러를 찾는다. HandlerMapping이라는 객체가 요청을 처리할 컨트롤러를 검색하는 역할을 하는데, 클라이언트의 요청 경로를 이용해 컨트롤러를 검색 후, 검색된 객체를 DispatcherServlet에게 전달한다. 컨트롤러를 실행시킨다. 즉, 비즈니스 로직을 처리한다. HandlerAdapter라는 객체가 컨트롤러를 실행시키는 역할을 하는데, @Controller 어노테이션을 이용하여 구현한 컨트롤러 뿐만 아니라, Controller 인터페이스를 구현한 컨트롤러, 특수 목적으로 사용되는 HttpRequestHandler 인터페이스를 구현한 클래스를 동일한 방식으로 실행할 수 있도록 한다. 실행된 Controller는 리턴할 데이터와 View를 HandlerAdapter에게 리턴한다. Handler Adapter는 데이터와 view를 ModelAndView 형태로 DispatcherServlet에게 리턴한다. 클라이언트에게 보여질 View를 찾는다. ViewResolver 객체가 클라이언트에게 보여질 view를 찾는 역할을 한다. 응답 데이터와 View를 클라이언트에게 전달한다. 최종적으로 ViewResolver 객체가 리턴한 View 객체에 응답 데이터를 넣어 클라이언트에게 리턴한다. ContextLoaderListener 웹 애플리케이션의 규모가 커진다면, 클라이언트의 요청 또한 다양해질 것이고, 이를 처리할, 즉 클라이언트의 요청을 처리하는 역할을 가진 DispatcherServlet도 늘어날 수 있다. 다른 성격을 가진 서블릿을 만들어야 할 수 있으니, 서블릿의 성격에 맞게 설정도 각각 적용시켜야 한다. 그러나 모든 서블릿이 공통으로 가져야 할 설정도 존재한다. 즉 Servlet Context 단위가 아닌, (Web) Application Context 단위의 설정이 필요한데, 이를 ContextLoaderListener 객체가 처리한다. Filter Filter란, 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 부분이다. e.g.) Spring Security Filter가 적용되어 있다면, 인가 및 인증 처리를 먼저 처리한 후 DispatcherServlet에게 요청을 전달할 것이다. e.g.) Encoding Filter가 적용되어 있다면 클라이언트의 요청 데이터를 인코딩하는 작업이 선 처리된 후 DispatcherServlet에게 필터링 된 데이터가 전달된다. ","permalink":"https://blog.litsynp.com/posts/2022/01/21/tir-about-web.xml/","summary":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란 웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다. DD는 웹 애플리케이션 실행 시 메모리에 로드된다. web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다. 설정이란 web.xml은 크게 세 개의 설정을 한다. DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리 DispatcherServlet DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.","title":"[TIR] About web.xml"},{"content":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages ","permalink":"https://blog.litsynp.com/posts/2022/01/07/tir-redis-vs-kafka-vs-rabbitmq/","summary":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned Means of communictaion between microservices: sync. and async. REST for sync. MQ for async. Considerations for choosing the right MQ: Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N Different message brokers and their purposes RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages ","title":"[TIR] Redis vs Kafka vs RabbitMQ"},{"content":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/01/05/drf-serializer%EC%97%90-writable-non-model-field-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/","summary":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow","title":"[DRF] Serializer에 writable non-model field 추가하기"},{"content":"문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인 아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/spring-boot%EC%97%90%EC%84%9C-swagger-ui-%EC%A0%91%EC%86%8D%EC%9D%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"문제 스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인 아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법 Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger-ui\u0026#39;, version: \u0026#39;3.0.0\u0026#39; implementation group: \u0026#39;io.springfox\u0026#39;, name: \u0026#39;springfox-swagger2\u0026#39;, version: \u0026#39;3.0.0\u0026#39; 다음과 같이 바꾼다.\nimplementation \u0026#34;io.springfox:springfox-boot-starter:3.0.0\u0026#34; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍","title":"Spring Boot에서 Swagger UI 접속이 안되는 경우"},{"content":"문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF Stack Overflow\n","permalink":"https://blog.litsynp.com/posts/2021/09/05/getting-ambiguous-exceptionhandler-method-mapped-for-xxxexception/","summary":"문제 스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인 스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법 @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF Stack Overflow","title":"Getting Ambiguous @ExceptionHandler method mapped for XXXException"},{"content":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.\u0026#39;} return Response(response, status=status.HTTP_403_FORBIDDEN) 아무튼 예시에 간략하게 설명을 덧붙이자면, 다음과 같다.\n제시한 destroy 함수는 DRF의 ModelViewSet 를 상속한 클래스인 UserViewSet 내의 함수이다. destroy 함수를 override하여 새로운 기능을 제공하고자 한다. 로그인한 사용자의 ID와, URL에 있는 parameter (/users/:pk)의 pk 부분, 즉 조회하려는 사용자의 ID가 일치하는지를 확인한다. 일치하면 super() 를 이용하여 기존 destroy 함수를 호출해 해당 사용자를 DB에서 삭제한다. 일치하지 않으면 HTTP 상태 코드 403 Forbidden와 함께 response 메세지를 JSON으로 반환한다. 참고 위와 같이 작성하면 물론 로그인을 했는지부터 확인해야하기 때문에 permission_classes를 작성해야 한다. 또한, 위의 함수만 작성하면 DRF의 admin site에서는 DELETE 버튼이 비활성화되지 않는다. (물론 클릭하면 권한에 따라 reject 될 것이다) REF Using super with a class method - (Stack Overflow)\n","permalink":"https://blog.litsynp.com/posts/2021/02/10/python-super-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B8%B0%EC%A1%B4-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/","summary":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.","title":"[Python] super() 이용해서 기존 메소드 이용하기"}]