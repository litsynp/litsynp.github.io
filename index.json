[{"content":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","permalink":"https://litsynp.github.io/posts/2022-01-07/","summary":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","title":"[TIR] Redis vs Kafka vs RabbitMQ"},{"content":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow\n","permalink":"https://litsynp.github.io/posts/2022-01-05/","summary":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow","title":"[DRF] Serializer에 writable non-model field 추가하기"},{"content":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '3.0.0' implementation group: 'io.springfox', name: 'springfox-swagger2', version: '3.0.0' 다음과 같이 바꾼다.\nimplementation \u0026quot;io.springfox:springfox-boot-starter:3.0.0\u0026quot; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍\n","permalink":"https://litsynp.github.io/posts/2021-09-05_2/","summary":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '3.0.0' implementation group: 'io.springfox', name: 'springfox-swagger2', version: '3.0.0' 다음과 같이 바꾼다.\nimplementation \u0026quot;io.springfox:springfox-boot-starter:3.0.0\u0026quot; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍","title":"Spring Boot에서 Swagger UI 접속이 안되는 경우"},{"content":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  [Stack Overflow] (https://stackoverflow.com/questions/51991992/getting-ambiguous-exceptionhandler-method-mapped-for-methodargumentnotvalidexce)\n","permalink":"https://litsynp.github.io/posts/2021-09-05/","summary":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  [Stack Overflow] (https://stackoverflow.com/questions/51991992/getting-ambiguous-exceptionhandler-method-mapped-for-methodargumentnotvalidexce)","title":"Getting Ambiguous @ExceptionHandler method mapped for XXXException"},{"content":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.\u0026#39;} return Response(response, status=status.HTTP_403_FORBIDDEN) 아무튼 예시에 간략하게 설명을 덧붙이자면, 다음과 같다.\n 제시한 destroy 함수는 DRF의 ModelViewSet 를 상속한 클래스인 UserViewSet 내의 함수이다. destroy 함수를 override하여 새로운 기능을 제공하고자 한다. 로그인한 사용자의 ID와, URL에 있는 parameter (/users/:pk)의 pk 부분, 즉 조회하려는 사용자의 ID가 일치하는지를 확인한다.  일치하면 super() 를 이용하여 기존 destroy 함수를 호출해 해당 사용자를 DB에서 삭제한다. 일치하지 않으면 HTTP 상태 코드 403 Forbidden와 함께 response 메세지를 JSON으로 반환한다.    참고  위와 같이 작성하면 물론 로그인을 했는지부터 확인해야하기 때문에 permission_classes를 작성해야 한다. 또한, 위의 함수만 작성하면 DRF의 admin site에서는 DELETE 버튼이 비활성화되지 않는다. (물론 클릭하면 권한에 따라 reject 될 것이다)  REF Using super with a class method - (Stack Overflow)\n","permalink":"https://litsynp.github.io/posts/2021-02-10/","summary":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.","title":"[Python] super() 이용해서 기존 메소드 이용하기"}]