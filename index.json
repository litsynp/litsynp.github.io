[{"content":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란  웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다.  DD는 웹 애플리케이션 실행 시 메모리에 로드된다.   web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다.  설정이란  web.xml은 크게 세 개의 설정을 한다.  DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리    DispatcherServlet   DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.\n  요청을 직접 처리하지 않고 적절한 객체에게 역할을 위임하여 클라이언트의 요청을 처리한다.\n  요청을 처리하기 위해서 크게 4가지 일이 진행되어야 한다.\n 클라이언트의 요청을 처리해줄 컨트롤러를 찾는다.  HandlerMapping이라는 객체가 요청을 처리할 컨트롤러를 검색하는 역할을 하는데, 클라이언트의 요청 경로를 이용해 컨트롤러를 검색 후, 검색된 객체를 DispatcherServlet에게 전달한다.   컨트롤러를 실행시킨다. 즉, 비즈니스 로직을 처리한다.  HandlerAdapter라는 객체가 컨트롤러를 실행시키는 역할을 하는데, @Controller 어노테이션을 이용하여 구현한 컨트롤러 뿐만 아니라, Controller 인터페이스를 구현한 컨트롤러, 특수 목적으로 사용되는 HttpRequestHandler 인터페이스를 구현한 클래스를 동일한 방식으로 실행할 수 있도록 한다. 실행된 Controller는 리턴할 데이터와 View를 HandlerAdapter에게 리턴한다. Handler Adapter는 데이터와 view를 ModelAndView 형태로 DispatcherServlet에게 리턴한다.   클라이언트에게 보여질 View를 찾는다.  ViewResolver 객체가 클라이언트에게 보여질 view를 찾는 역할을 한다.   응답 데이터와 View를 클라이언트에게 전달한다.  최종적으로 ViewResolver 객체가 리턴한 View 객체에 응답 데이터를 넣어 클라이언트에게 리턴한다.      ContextLoaderListener  웹 애플리케이션의 규모가 커진다면, 클라이언트의 요청 또한 다양해질 것이고, 이를 처리할, 즉 클라이언트의 요청을 처리하는 역할을 가진 DispatcherServlet도 늘어날 수 있다. 다른 성격을 가진 서블릿을 만들어야 할 수 있으니, 서블릿의 성격에 맞게 설정도 각각 적용시켜야 한다. 그러나 모든 서블릿이 공통으로 가져야 할 설정도 존재한다. 즉 Servlet Context 단위가 아닌, (Web) Application Context 단위의 설정이 필요한데, 이를 ContextLoaderListener 객체가 처리한다.  Filter  Filter란, 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 부분이다. e.g.) Spring Security Filter가 적용되어 있다면, 인가 및 인증 처리를 먼저 처리한 후 DispatcherServlet에게 요청을 전달할 것이다. e.g.) Encoding Filter가 적용되어 있다면 클라이언트의 요청 데이터를 인코딩하는 작업이 선 처리된 후 DispatcherServlet에게 필터링 된 데이터가 전달된다.  ","permalink":"https://litsynp.github.io/posts/2022-01-21/","summary":"Today I Read Reference https://tlatmsrud.tistory.com/35\nWhat I Learned web.xml이란  웹 애플리케이션의 설정파일이다. DD (Deployment Description, 배포 설명자) 라고 불린다.  DD는 웹 애플리케이션 실행 시 메모리에 로드된다.   web.xml이란, 웹 애플리케이션을 실행시킬 때 함께 올라가야 할 설정들을 정의해놓은 파일이다.  설정이란  web.xml은 크게 세 개의 설정을 한다.  DispatcherServlet: 클라이언트의 요청을 전달 받아 처리 ContextLoaderListener: 웹 애플리케이션 컨텍스트 단위 설정을 로드 Filter: 클라이언트에서 온 요청을 DispatcherServlet이 받기 전 거치는 과정 처리    DispatcherServlet   DispatcherServlet은 클라이언트의 요청을 전달받아 요청을 처리하는 객체이다.","title":"[TIR] About web.xml"},{"content":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","permalink":"https://litsynp.github.io/posts/2022-01-07/","summary":"Today I Read Link https://blog.devgenius.io/redis-vs-kafka-vs-rabbitmq-e935ebbc7ec\nWhat I Learned  Means of communictaion between microservices: sync. and async.  REST for sync. MQ for async.   Considerations for choosing the right MQ:  Broker scale: # messages / sec. Data persistency: the ability to recover messages Consumer capability: Capability for 1:1 or 1:N   Different message brokers and their purposes  RabbitMQ (AMQP) for complex routing Kafka for large amounts of data Redis for short-lived messages    ","title":"[TIR] Redis vs Kafka vs RabbitMQ"},{"content":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow\n","permalink":"https://litsynp.github.io/posts/2022-01-05/","summary":"문제 Django 및 DRF에서 model에 정의하지 않은 필드를 POST / PUT용 serializer에 추가하고 싶을 때가 있다. 그냥 serializers.CharField()로 추가하면 unexpected keyword라고 뜨면서 추가할 수 없는 문제가 발생한다.\n해결법 Serializer에 추가해둔 필드를 validate 메소드에서 model 생성에 사용되지 않도록 pop() 시켜준다.\nclass UserSerializer(serializers.ModelSerializer): non_model_field = serializers.CharField(max_length=300, allow_blank=True, write_only=True) class Meta: model = User fields = (\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;non_model_field\u0026#39;) def validate(self, attrs): # ... attrs.pop(\u0026#39;non_model_field\u0026#39;, None) return super().validate(attrs) REF Stack Overflow","title":"[DRF] Serializer에 writable non-model field 추가하기"},{"content":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '3.0.0' implementation group: 'io.springfox', name: 'springfox-swagger2', version: '3.0.0' 다음과 같이 바꾼다.\nimplementation \u0026quot;io.springfox:springfox-boot-starter:3.0.0\u0026quot; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍\n","permalink":"https://litsynp.github.io/posts/2021-09-05_2/","summary":"문제  스프링 부트에서 Swagger2의 3.0.0 버전을 의존성에 추가했는데, /v2/api-docs는 접근이 되는데 /swagger-ui는 접근이 안됨.\n원인  아마도 dependencies를 잘못 설정했을 확률이 높다.\n해결법  Gradle 기준, build.gradle에서 다음과 같이 설정되어 있다면,\nimplementation group: 'io.springfox', name: 'springfox-swagger-ui', version: '3.0.0' implementation group: 'io.springfox', name: 'springfox-swagger2', version: '3.0.0' 다음과 같이 바꾼다.\nimplementation \u0026quot;io.springfox:springfox-boot-starter:3.0.0\u0026quot; 다시 빌드하고 /swagger-ui endpoint로 접속해보면 성공!👍","title":"Spring Boot에서 Swagger UI 접속이 안되는 경우"},{"content":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  Stack Overflow\n","permalink":"https://litsynp.github.io/posts/2021-09-05/","summary":"문제  스프링에서 @ControllerAdvice를 이용해 전역 exception handler를 직접 만들 때, @ExceptionHandler(XXXException.class)를 어노테이션으로 메소드에 달았을 때,\nGetting Ambiguous @ExceptionHandler method mapped for XXXException 라는 오류가 뜨는 경우가 있다.\n원인  스프링의 @ExceptionHandler에 이미 MethodArgumentNotValidException이 이미 구현이 되어있기 때문에 동일한 두 개의 핸들러가 존재하게 되기 때문에 발생한다.\n해결법  @ExceptionHandler 어노테이션을 사용하는 대신, @Override 어노테이션을 이용해 해당 핸들러를 직접 오버라이드한다. (REF 참고)\nREF  Stack Overflow","title":"Getting Ambiguous @ExceptionHandler method mapped for XXXException"},{"content":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.\u0026#39;} return Response(response, status=status.HTTP_403_FORBIDDEN) 아무튼 예시에 간략하게 설명을 덧붙이자면, 다음과 같다.\n 제시한 destroy 함수는 DRF의 ModelViewSet 를 상속한 클래스인 UserViewSet 내의 함수이다. destroy 함수를 override하여 새로운 기능을 제공하고자 한다. 로그인한 사용자의 ID와, URL에 있는 parameter (/users/:pk)의 pk 부분, 즉 조회하려는 사용자의 ID가 일치하는지를 확인한다.  일치하면 super() 를 이용하여 기존 destroy 함수를 호출해 해당 사용자를 DB에서 삭제한다. 일치하지 않으면 HTTP 상태 코드 403 Forbidden와 함께 response 메세지를 JSON으로 반환한다.    참고  위와 같이 작성하면 물론 로그인을 했는지부터 확인해야하기 때문에 permission_classes를 작성해야 한다. 또한, 위의 함수만 작성하면 DRF의 admin site에서는 DELETE 버튼이 비활성화되지 않는다. (물론 클릭하면 권한에 따라 reject 될 것이다)  REF Using super with a class method - (Stack Overflow)\n","permalink":"https://litsynp.github.io/posts/2021-02-10/","summary":"Why use it? 프로젝트에서 Django REST Framework를 사용하고 있는데, serializer나 viewset을 사용할 때, 특히 ModelViewSet 을 override할 때 HTTP 메소드에 따른 함수를 수정하고 싶을 때가 있다.\n그럴 때 특정 분기에 따라 override하기 전의 클래스 메소드를 사용하고 싶은 때가 있다.\n예시는 다음과 같다.\n# ViewSet 안의 메소드 def destroy(self, request, *args, **kwargs): user_id = int(self.kwargs.get(\u0026#39;pk\u0026#39;)) # 로그인한 사용자와 조회하려는 사용자의 ID가 일치한지 확인 if self.request.user.id == user_id: return super(UserViewSet, self).destroy(request, *args, **kwargs) else: response = { \u0026#39;detail\u0026#39;: \u0026#39;Delete function is not offered without authorization as the owner.","title":"[Python] super() 이용해서 기존 메소드 이용하기"}]